<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>í¬ë¡œë§ˆ ìŠ¤í… (Chroma Step) - MVP v2.6</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        :root {
            --color-bg: #121212; --color-text: #e0e0e0; --color-ui-bg: #1e1e1e;
            --color-cyan: #18ffff; --color-yellow: #ffc400;
        }

        body {
            margin: 0; padding: 0; font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--color-bg); color: var(--color-text);
            display: flex; justify-content: center; align-items: center;
            width: 100vw; height: 100vh; overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            width: 100%; max-width: 1000px; height: 100%;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; position: relative;
        }

        #canvas-container {
            width: 100%; height: 80%; background-color: #000;
            border-radius: 16px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            position: relative;
        }

        canvas { 
            display: block; width: 100%; height: 100%; border-radius: 16px;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .ui-panel {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(18, 18, 18, 0.95); display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 10; border-radius: 16px; text-align: center;
            padding: 20px; box-sizing: border-box; animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        .ui-panel h1 { font-size: 3rem; margin-bottom: 10px; letter-spacing: 2px; text-shadow: 0 0 10px var(--color-cyan); }
        .ui-panel p { font-size: 1.2rem; margin-bottom: 30px; }

        .ui-button {
            padding: 15px 30px; font-size: 1.2rem; font-weight: 700;
            color: var(--color-bg); background-color: var(--color-cyan);
            border: none; border-radius: 50px; cursor: pointer;
            transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(24, 255, 255, 0.3);
            margin: 5px;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .ui-button:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(24, 255, 255, 0.5); }
        
        #game-over-panel .stats { margin: 20px 0; font-size: 1.5rem; }
        #game-over-panel .new-highscore { color: var(--color-yellow); animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        
        /* ì½¤ë³´ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes comboBoost {
            0% { transform: scale(1); color: inherit; }
            50% { transform: scale(1.2); color: var(--color-yellow); text-shadow: 0 0 10px var(--color-yellow); }
            100% { transform: scale(1); color: inherit; text-shadow: none; }
        }
        
        @keyframes screenFlash {
            0% { background-color: transparent; }
            50% { background-color: rgba(255, 255, 255, 0.1); }
            100% { background-color: transparent; }
        }
        
        .combo-boost {
            animation: comboBoost 0.5s ease-out;
        }
        
        .screen-flash {
            animation: screenFlash 0.3s ease-out;
        }
        
        /* ì„±ê³µ íƒ€ì¼ íš¨ê³¼ */
        @keyframes tileSuccess {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-10px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }
        
        .tile-success {
            animation: tileSuccess 0.4s ease-out;
        }

        #hud {
            width: 100%; padding: 20px; box-sizing: border-box; position: absolute;
            top: 0; left: 0; z-index: 5; display: flex; justify-content: space-between;
            align-items: flex-start;
        }
        .hud-group { background-color: rgba(30, 30, 30, 0.8); padding: 10px 20px; border-radius: 12px; backdrop-filter: blur(5px); }
        #score-display, #combo-display { font-size: 1.5rem; font-weight: 700; }
        #combo-display { color: #ffab40; }
        #time-bar-container { width: 100%; height: 10px; background-color: rgba(255,255,255,0.2); border-radius: 5px; margin-top: 5px; }
        #time-bar { width: 100%; height: 100%; background-color: #69f0ae; border-radius: 5px; transition: width 0.1s linear; }
        #mission-display {
            display: flex; gap: 8px; padding: 10px; background-color: rgba(30, 30, 30, 0.8);
            border-radius: 12px; backdrop-filter: blur(5px); position: absolute;
            top: 20px; left: 50%; transform: translateX(-50%); pointer-events: none;
        }
        .mission-color {
            width: 40px; height: 40px; border-radius: 50%; border: 3px solid var(--color-text);
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        .mission-color.current { transform: scale(1.3); box-shadow: 0 0 20px #fff, 0 0 30px rgba(255, 255, 255, 0.5); }
        .mission-success-anim { animation: missionSuccess 0.5s ease-in-out; }
        @keyframes missionSuccess {
            0% { transform: scale(1.2); box-shadow: 0 0 15px #fff; }
            50% { transform: scale(1.5); box-shadow: 0 0 25px var(--color-yellow); }
            100% { transform: scale(0); opacity: 0; }
        }

        #pause-button {
            background-color: rgba(30, 30, 30, 0.8); backdrop-filter: blur(5px);
            border: 2px solid var(--color-text); color: var(--color-text);
            width: 50px; height: 50px; font-size: 1.5rem;
            border-radius: 50%; cursor: pointer;
            margin-left: 15px;
        }

        #settings-panel .theme-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 15px; width: 100%; max-width: 400px;
        }
        .theme-option { display: flex; align-items: center; width: 100%; }
        .theme-button {
            flex-grow: 1; text-align: left; border: 2px solid var(--color-text);
            background-color: transparent; color: var(--color-text);
        }
        .theme-button.selected {
            border-color: var(--color-cyan); background-color: rgba(24, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(24, 255, 255, 0.5);
        }
        .theme-preview { display: flex; margin-left: 15px; }
        .theme-swatch {
            width: 20px; height: 20px; border-radius: 50%;
            margin-left: -5px; border: 2px solid var(--color-bg);
        }

        /* ëª¨ë°”ì¼ ê°€ìƒ í‚¤ë³´ë“œ ìŠ¤íƒ€ì¼ */
        #virtual-keyboard {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 1000; pointer-events: none; display: none;
        }
        #virtual-keyboard.show {
            display: block;
        }
        .keyboard-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 10px; pointer-events: auto;
        }
        .keyboard-row {
            display: flex; gap: 15px; align-items: center;
        }
        .keyboard-key {
            width: 60px; height: 60px; border-radius: 50%;
            background-color: rgba(30, 30, 30, 0.9); color: var(--color-text);
            border: 2px solid var(--color-cyan); font-size: 20px; font-weight: bold;
            cursor: pointer; transition: all 0.2s ease;
            backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .keyboard-key:hover, .keyboard-key:active {
            background-color: var(--color-cyan); color: var(--color-bg);
            transform: scale(1.1); box-shadow: 0 6px 20px rgba(24, 255, 255, 0.4);
        }
        .keyboard-key:active {
            transform: scale(0.95);
        }
        

        /* ì„¤ì • íŒ¨ë„ ìŠ¤íƒ€ì¼ */
        .settings-section {
            margin-bottom: 30px; width: 100%; max-width: 400px;
        }
        .setting-item {
            display: flex; align-items: center; margin-bottom: 10px;
        }
        .setting-label {
            display: flex; align-items: center; cursor: pointer;
            font-size: 1.1rem; gap: 10px;
        }
        .setting-label input[type="checkbox"] {
            width: 20px; height: 20px; cursor: pointer;
        }

        /* íŠœí† ë¦¬ì–¼ ëª¨ë°”ì¼ ìµœì í™” */
        #tutorial-content {
            transition: all 0.3s ease;
        }
        
        /* ëª¨ë°”ì¼ HUD ìµœì í™” */
        @media (max-width: 768px) {
            #hud {
                padding: 5px;
            }
            .hud-group {
                padding: 5px 8px;
            }
            #score-display, #combo-display {
                font-size: 0.9rem;
            }
            #time-display {
                font-size: 0.9rem;
            }
            #mission-display {
                top: 5px;
                gap: 6px;
                padding: 8px;
            }
            .mission-color {
                width: 35px;
                height: 35px;
                border-width: 2px;
            }
            #pause-button {
                width: 35px;
                height: 35px;
                font-size: 1.2rem;
            }
            
            /* íŠœí† ë¦¬ì–¼ ëª¨ë°”ì¼ ìµœì í™” */
            #tutorial-content {
                top: 10px !important;
                max-width: 95% !important;
                padding: 15px !important;
                width: auto !important;
                max-height: 200px;
                overflow-y: auto;
            }
            
            #tutorial-title {
                font-size: 1.1rem !important;
            }
            
            #tutorial-description {
                font-size: 1rem !important;
                margin-bottom: 15px !important;
            }
            
            #tutorial-controls {
                flex-direction: column;
                gap: 8px !important;
            }
            
            #tutorial-controls > div {
                display: flex;
                justify-content: center;
                gap: 8px;
            }
            
            #tutorial-skip, #tutorial-prev, #tutorial-next {
                font-size: 0.9rem !important;
                padding: 8px 16px !important;
                flex: 1;
                max-width: 120px;
            }
        }
        
        /* ì‘ì€ ëª¨ë°”ì¼ í™”ë©´ (ì•„ì´í° SE ë“±) */
        @media (max-width: 480px) {
            #tutorial-content {
                top: 5px !important;
                max-height: 180px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="canvas-container">
            <canvas id="game-canvas"></canvas>
            <div id="hud" style="display: none;">
                <div class="hud-group">
                    <div id="score-display">Score: 0</div>
                    <div id="combo-display">Combo: x1.0</div>
                </div>
                <div class="hud-group" style="display: flex; align-items: center;">
                    <div>
                        <div id="time-display">Time: 60.0</div>
                        <div id="time-bar-container"><div id="time-bar"></div></div>
                    </div>
                    <button id="pause-button">||</button>
                </div>
                <div id="invincibility-timer" style="display: none; position: absolute; top: 80px; right: 20px; background: rgba(255, 255, 0, 0.9); color: black; padding: 8px 16px; border-radius: 8px; font-size: 1.2rem; font-weight: bold; z-index: 1000;">
                    ë¬´ì : <span id="invincibility-countdown">5</span>ì´ˆ
                </div>
            </div>
            <div id="mission-display" style="display: none;"></div>
            <div id="main-menu" class="ui-panel">
                <h1 style="font-size: 3.5rem; margin-bottom: 20px;">CHROMA STEP</h1>
                <div style="text-align: center; margin-bottom: 20px;">
                    <p style="font-size: 1.2rem; margin: 5px 0;">ë ˆë²¨ <span id="player-level">1</span></p>
                    <div style="width: 200px; height: 8px; background-color: rgba(255,255,255,0.2); border-radius: 4px; margin: 8px auto;">
                        <div id="exp-bar" style="width: 0%; height: 100%; background-color: var(--color-cyan); border-radius: 4px; transition: width 0.3s ease;"></div>
                    </div>
                    <p style="font-size: 0.9rem; margin: 5px 0; opacity: 0.8;"><span id="exp-display">0</span> / <span id="exp-needed">500</span> EXP</p>
                    <p style="font-size: 1rem; margin: 10px 0;">ìµœê³  ì ìˆ˜: <span id="high-score">0</span></p>
                </div>
                <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                    <button id="start-button" class="ui-button">ê²Œì„ ì‹œì‘</button>
                    <button id="tutorial-button" class="ui-button">íŠœí† ë¦¬ì–¼</button>
                    <button id="settings-button" class="ui-button">ì„¤ì •</button>
                </div>
            </div>
            <div id="game-over-panel" class="ui-panel" style="display: none;">
                <h1>GAME OVER</h1>
                <div class="stats">
                    <p>Final Score: <span id="final-score">0</span></p>
                    <p class="new-highscore" style="display: none;">NEW HIGH SCORE!</p>
                    <p>Color Sparks: +<span id="sparks-earned">0</span></p>
                </div>
                <button id="restart-button" class="ui-button">ë‹¤ì‹œ ì‹œì‘</button>
            </div>
            <div id="settings-panel" class="ui-panel" style="display: none;">
                <h1>ì„¤ì •</h1>
                <div class="settings-section">
                    <h2 style="font-size: 1.5rem; margin-bottom: 15px;">ìƒ‰ìƒ í…Œë§ˆ</h2>
                    <div id="theme-container" class="theme-container"></div>
                </div>
                <div class="settings-section">
                    <h2 style="font-size: 1.5rem; margin-bottom: 15px;">ëª¨ë°”ì¼ ì„¤ì •</h2>
                    <div class="setting-item">
                        <label class="setting-label">
                            <input type="checkbox" id="virtual-keyboard-toggle" />
                            <span>ê°€ìƒ í‚¤ë³´ë“œ í‘œì‹œ</span>
                        </label>
                    </div>
                </div>
                <button id="back-to-menu-button" class="ui-button">ë’¤ë¡œ ê°€ê¸°</button>
            </div>
            <div id="pause-panel" class="ui-panel" style="display: none;">
                <h1>ì¼ì‹œì •ì§€</h1>
                <button id="resume-button" class="ui-button">ê³„ì†í•˜ê¸°</button>
                <button id="home-button" class="ui-button">í™ˆìœ¼ë¡œ</button>
            </div>
            
            <!-- íŠœí† ë¦¬ì–¼ ì˜¤ë²„ë ˆì´ -->
            <div id="tutorial-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 2000;">
                <div id="tutorial-content" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); max-width: 90%; width: 400px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);">
                    <div id="tutorial-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 id="tutorial-title" style="margin: 0; font-size: 1.3rem; color: #333; font-weight: bold;">íŠœí† ë¦¬ì–¼</h3>
                        <span id="tutorial-progress" style="font-size: 1rem; color: #666; font-weight: bold;">1/7</span>
                    </div>
                    <div id="tutorial-description" style="margin-bottom: 20px; font-size: 1.1rem; color: #333; line-height: 1.5; text-align: center;">
                        ê²Œì„ì„ ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤!
                    </div>
                    <div id="tutorial-controls" style="display: flex; justify-content: space-between; gap: 10px;">
                        <button id="tutorial-skip" class="ui-button" style="background: #666; font-size: 1rem; padding: 10px 18px;">ê±´ë„ˆë›°ê¸°</button>
                        <div style="display: flex; gap: 10px;">
                            <button id="tutorial-prev" class="ui-button" style="font-size: 1rem; padding: 10px 18px;" disabled>ì´ì „</button>
                            <button id="tutorial-next" class="ui-button" style="font-size: 1rem; padding: 10px 18px;">ë‹¤ìŒ</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ëª¨ë°”ì¼ ê°€ìƒ í‚¤ë³´ë“œ -->
        <div id="virtual-keyboard" style="display: none;">
            <div class="keyboard-container">
                <div class="keyboard-row">
                    <button id="key-up" class="keyboard-key">â†‘</button>
                </div>
                <div class="keyboard-row">
                    <button id="key-left" class="keyboard-key">â†</button>
                    <button id="key-down" class="keyboard-key">â†“</button>
                    <button id="key-right" class="keyboard-key">â†’</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- í¬ë¡œë§ˆ ìŠ¤í… MVP ìŠ¤í¬ë¦½íŠ¸ ---
        // ê¸°íšì„œ ë²„ì „ 1.2 ê¸°ë°˜ / ìˆ˜ì •ì‚¬í•­ v2.6 (Color Fix)
        
        const scene = new THREE.Scene();
        const canvas = document.querySelector('#game-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        const camera = new THREE.OrthographicCamera(
            canvas.clientWidth / -2, canvas.clientWidth / 2,
            canvas.clientHeight / 2, canvas.clientHeight / -2,
            1, 1000
        );
        const cameraTarget = new THREE.Vector3(0, 0, 0);
        camera.position.set(0, 60, 60); 
        camera.lookAt(cameraTarget);

        // *** ìˆ˜ì •: ìƒ‰ìƒ í…Œë§ˆ ê°œí¸ ***
        const COLOR_THEMES = {
            'ì„ ëª…í•œ ë¬´ì§€ê°œ': [0xf44336, 0xff9800, 0xffeb3b, 0x4caf50, 0x2196f3, 0x3f51b5, 0x9c27b0],
            'ë„¤ì˜¨ì˜ ê¿ˆ': [0xf06292, 0x4fc3f7, 0xffee58, 0x81c784, 0xba68c8, 0xff8a65, 0x4dd0e1],
            'ì‚¬ì´ë²„í‘í¬ ë„¤ì˜¨': [0xff00ff, 0x00ffff, 0x00ff00, 0xffff00, 0xff00aa, 0x00aaff, 0xaa00ff],
            'íŒŒìŠ¤í…” ì •ì›': [0xef9a9a, 0xa5d6a7, 0xffcc80, 0x90caf9, 0xce93d8, 0xf48fb1, 0x80cbc4]
        };
        const DEACTIVATED_COLOR = 0x424242;
        let currentThemeColors = [];

        // ì´ë²¤íŠ¸ ë¸”ë¡ ì‹œìŠ¤í…œ
        const EVENT_BLOCK_TYPES = {
            TIME_GAIN: 'time_gain',
            TIME_LOSS: 'time_loss',
            INVINCIBILITY: 'invincibility'
        };

        const EVENT_BLOCK_CONFIG = {
            SPAWN_PROBABILITY: 0.02, // 2% í™•ë¥ 
            TIME_GAIN_AMOUNT: 5,
            TIME_LOSS_AMOUNT: 5,
            INVINCIBILITY_DURATION: 5,
            COLORS: {
                TIME_GAIN: 0x00ff00,    // ì´ˆë¡ìƒ‰
                TIME_LOSS: 0xff0000,    // ë¹¨ê°„ìƒ‰
                INVINCIBILITY: 0xffff00  // ë…¸ë€ìƒ‰
            }
        };

        const GAME_CONFIG = {
            INITIAL_TIME: 45, BASE_SCORE_PER_TILE: 100,
            COMBO_MULTIPLIER: 0.15, MAX_COMBO_BONUS: 4.0,
            TIME_REWARD_BASE: 1.5,
            TILE_SIZE: 5, TILE_GAP: 1, GRID_RADIUS: 15, 
            TILE_RESPAWN_TIME: 4000,
            TIME_PENALTY_PER_MOVE: 1.0,
            TIME_DECAY_RATE: 1.2, // ì‹œê°„ë‹¹ ì¶”ê°€ ê°ì†Œìœ¨
        };
        
        let gameState = 'MENU';
        // ë³´ìƒ ì‹œìŠ¤í…œ ì„¤ì •
        const REWARD_SYSTEM = {
            levels: [0, 500, 1200, 2000, 3500, 5500, 8000, 12000, 17000, 25000], // ë ˆë²¨ì—… í•„ìš” ì ìˆ˜
            skins: [
                { id: 'basic', name: 'ê¸°ë³¸', color: 0xffffff, unlockLevel: 0 },
                { id: 'neon', name: 'ë„¤ì˜¨', color: 0x00ffff, unlockLevel: 2 },
                { id: 'gold', name: 'í™©ê¸ˆ', color: 0xffd700, unlockLevel: 4 },
                { id: 'rainbow', name: 'ë¬´ì§€ê°œ', color: 0xff69b4, unlockLevel: 6 },
                { id: 'crystal', name: 'í¬ë¦¬ìŠ¤íƒˆ', color: 0x9370db, unlockLevel: 8 }
            ]
        };

        // ë¯¸ì…˜ ì‹œìŠ¤í…œ í™•ì¥
        const MISSION_TYPES = {
            SINGLE_COLOR: 'single_color',      // ê¸°ì¡´: ë‹¨ì¼ ìƒ‰ìƒ
            SEQUENCE: 'sequence',              // ì—°ì† ìƒ‰ìƒ (ë¹¨ê°•->íŒŒë‘->ì´ˆë¡)
            DOUBLE: 'double',                  // ê°™ì€ ìƒ‰ìƒ 2ê°œ ì—°ì†
            RAINBOW: 'rainbow',                // ëª¨ë“  ìƒ‰ìƒ í•œë²ˆì”©
            TIME_RUSH: 'time_rush',            // ì œí•œ ì‹œê°„ ë‚´ Nê°œ
            PATTERN: 'pattern'                 // íŠ¹ì • íŒ¨í„´ (Lì, ì‹­ì ë“±)
        };

        const MISSION_CONFIGS = {
            [MISSION_TYPES.SINGLE_COLOR]: {
                name: 'ìƒ‰ìƒ ë§¤ì¹­',
                description: 'ì§€ì •ëœ ìƒ‰ìƒ ë°Ÿê¸°',
                baseReward: 100,
                icon: 'â—'
            },
            [MISSION_TYPES.SEQUENCE]: {
                name: 'ìƒ‰ìƒ ìˆœì„œ',
                description: 'ìˆœì„œëŒ€ë¡œ ìƒ‰ìƒ ë°Ÿê¸°',
                baseReward: 200,
                icon: 'â†’'
            },
            [MISSION_TYPES.DOUBLE]: {
                name: 'ë”ë¸” ë§¤ì¹˜',
                description: 'ê°™ì€ ìƒ‰ìƒ 2ë²ˆ ì—°ì†',
                baseReward: 150,
                icon: 'â—â—'
            },
            [MISSION_TYPES.RAINBOW]: {
                name: 'ë¬´ì§€ê°œ',
                description: 'ëª¨ë“  ìƒ‰ìƒ í•œë²ˆì”©',
                baseReward: 300,
                icon: 'ğŸŒˆ'
            },
            [MISSION_TYPES.TIME_RUSH]: {
                name: 'íƒ€ì„ ëŸ¬ì‹œ',
                description: '5ì´ˆ ë‚´ 3ê°œ ìƒ‰ìƒ',
                baseReward: 250,
                icon: 'â°'
            }
        };

        // ë„ì „ê³¼ì œ ì‹œìŠ¤í…œ
        const ACHIEVEMENTS = {
            first_steps: { name: 'ì²« ê±¸ìŒ', desc: 'ì²« ë²ˆì§¸ íƒ€ì¼ ë°Ÿê¸°', target: 1, reward: 50 },
            combo_starter: { name: 'ì½¤ë³´ ì‹œì‘', desc: '5ì½¤ë³´ ë‹¬ì„±', target: 5, reward: 100 },
            combo_master: { name: 'ì½¤ë³´ ë§ˆìŠ¤í„°', desc: '15ì½¤ë³´ ë‹¬ì„±', target: 15, reward: 200 },
            combo_legend: { name: 'ì½¤ë³´ ì „ì„¤', desc: '25ì½¤ë³´ ë‹¬ì„±', target: 25, reward: 500 },
            score_hunter: { name: 'ì ìˆ˜ ì‚¬ëƒ¥ê¾¼', desc: '1000ì  ë‹¬ì„±', target: 1000, reward: 100 },
            score_champion: { name: 'ì ìˆ˜ ì±”í”¼ì–¸', desc: '5000ì  ë‹¬ì„±', target: 5000, reward: 300 },
            time_survivor: { name: 'ì‹œê°„ ìƒì¡´ì', desc: '2ë¶„ ìƒì¡´', target: 120, reward: 200 },
            special_collector: { name: 'íŠ¹ìˆ˜ ìˆ˜ì§‘ê°€', desc: 'íŠ¹ìˆ˜ ë¸”ë¡ 10ê°œ ë°Ÿê¸°', target: 10, reward: 150 }
        };

        let gameData = {
            score: 0, time: GAME_CONFIG.INITIAL_TIME, combo: 1,
            currentMission: [],
            highScore: 0, colorSparks: 0,
            isInvincible: false,
            invincibilityEndTime: 0,
            // ì§„í–‰ ì‹œìŠ¤í…œ
            totalScore: 0, // ëˆ„ì  ì ìˆ˜
            level: 1,
            experience: 0,
            currentSkin: 'basic',
            // ë„ì „ê³¼ì œ ì‹œìŠ¤í…œ
            achievements: {},
            sessionStats: {
                tilesPressed: 0,
                maxCombo: 0,
                specialBlocksCollected: 0,
                survivalTime: 0
            },
            // í™•ì¥ëœ ë¯¸ì…˜ ì‹œìŠ¤í…œ
            currentMissionType: MISSION_TYPES.SINGLE_COLOR,
            missionProgress: [],
            rainbowProgress: new Set(),
            timeRushStartTime: 0,
            missionStartTime: 0
        };
        let gameSettings = {
            theme: 'ì„ ëª…í•œ ë¬´ì§€ê°œ',
            showVirtualKeyboard: true
        };
        
        // íŠœí† ë¦¬ì–¼ ì‹œìŠ¤í…œ
        const tutorialSteps = [
            {
                id: 0,
                title: "ê²Œì„ ì†Œê°œ",
                description: "CHROMA STEPì— ì˜¤ì‹  ê±¸ í™˜ì˜í•©ë‹ˆë‹¤! ìƒ‰ê¹” ë¸”ë¡ì„ ë°Ÿì•„ ë¯¸ì…˜ì„ ì™„ë£Œí•˜ëŠ” ë¦¬ë“¬ ê²Œì„ì…ë‹ˆë‹¤.",
                highlight: null,
                playerCanMove: false,
                autoNext: false
            },
            {
                id: 1,
                title: "ì´ë™ ë°©ë²•",
                description: "ë°©í–¥í‚¤ ë˜ëŠ” WASDë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•œ ë²ˆ ì´ë™í•´ë³´ì„¸ìš”!",
                highlight: "player",
                playerCanMove: true,
                autoNext: true,
                waitForMove: true
            },
            {
                id: 2,
                title: "ë¯¸ì…˜ ì‹œìŠ¤í…œ",
                description: "í™”ë©´ ìƒë‹¨ì— í‘œì‹œëœ ìƒ‰ê¹”ì´ í˜„ì¬ ë¯¸ì…˜ì…ë‹ˆë‹¤. ì´ ìƒ‰ê¹”ê³¼ ì¼ì¹˜í•˜ëŠ” ë¸”ë¡ì„ ì°¾ì•„ ë°Ÿìœ¼ì„¸ìš”!",
                highlight: "mission",
                playerCanMove: true,
                autoNext: false,
                forcedMissionColor: 0
            },
            {
                id: 3,
                title: "ì˜¬ë°”ë¥¸ ë¸”ë¡ ë°Ÿê¸°",
                description: "ë¯¸ì…˜ ìƒ‰ê¹”ê³¼ ì¼ì¹˜í•˜ëŠ” ë¸”ë¡ì„ ë°Ÿìœ¼ë©´ ì ìˆ˜ë¥¼ ì–»ìŠµë‹ˆë‹¤. í•œ ë²ˆ ë°Ÿì•„ë³´ì„¸ìš”!",
                highlight: "tile",
                playerCanMove: true,
                autoNext: true,
                waitForCorrectTile: true
            },
            {
                id: 4,
                title: "ì½¤ë³´ ì‹œìŠ¤í…œ",
                description: "ì—°ì†ìœ¼ë¡œ ì„±ê³µí•˜ë©´ ì½¤ë³´ê°€ ì¦ê°€í•˜ì—¬ ë” ë§ì€ ì ìˆ˜ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!",
                highlight: "combo",
                playerCanMove: true,
                autoNext: false
            },
            {
                id: 5,
                title: "íŠ¹ìˆ˜ ë¸”ë¡",
                description: "ê°€ë” íŠ¹ìˆ˜ ë¸”ë¡ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤. ì´ˆë¡ìƒ‰(+T)ì€ ì‹œê°„ ì¦ê°€, ë¹¨ê°„ìƒ‰(-T)ì€ ì‹œê°„ ê°ì†Œ, ë…¸ë€ìƒ‰(â˜…)ì€ ë¬´ì  ìƒíƒœì…ë‹ˆë‹¤.",
                highlight: null,
                playerCanMove: true,
                autoNext: false
            },
            {
                id: 6,
                title: "ì‹œê°„ ê´€ë¦¬",
                description: "ì‹œê°„ì´ ë‹¤ ë–¨ì–´ì§€ë©´ ê²Œì„ ì˜¤ë²„! ì˜¬ë°”ë¥¸ ë¸”ë¡ì„ ë°Ÿìœ¼ë©´ ì‹œê°„ì´ íšŒë³µë©ë‹ˆë‹¤. ì´ì œ ì‹¤ì œ ê²Œì„ì„ ì‹œì‘í•´ë³´ì„¸ìš”!",
                highlight: "time",
                playerCanMove: true,
                autoNext: false,
                isLastStep: true
            }
        ];
        
        let tutorialData = {
            isActive: false,
            currentStep: 0,
            hasPlayerMoved: false,
            hasSteppedCorrectTile: false
        };
        
        let player, clock = new THREE.Clock(), tiles = new Map(), directionalLight;
        let frameCounter = 0; // ì„±ëŠ¥ ìµœì í™”ìš© í”„ë ˆì„ ì¹´ìš´í„°
        
        // ì´ë²¤íŠ¸ ë¸”ë¡ ìƒì„± í™•ë¥  ì²´í¬
        function shouldCreateEventBlock() {
            if (Math.random() < EVENT_BLOCK_CONFIG.SPAWN_PROBABILITY) {
                const types = Object.values(EVENT_BLOCK_TYPES);
                return types[Math.floor(Math.random() * types.length)];
            }
            return null;
        }
        
        // ì´ë²¤íŠ¸ ë¸”ë¡ì— ì‹¬ë³¼ ì¶”ê°€
        function addEventBlockSymbol(tileMesh, eventBlockType) {
            const symbolGeometry = new THREE.PlaneGeometry(4, 4); // í¬ê¸° ì¦ê°€
            let symbolText = '';
            
            switch(eventBlockType) {
                case EVENT_BLOCK_TYPES.TIME_GAIN:
                    symbolText = '+T';
                    break;
                case EVENT_BLOCK_TYPES.TIME_LOSS:
                    symbolText = '-T';
                    break;
                case EVENT_BLOCK_TYPES.INVINCIBILITY:
                    symbolText = 'â˜…';
                    break;
            }
            
            // í…ìŠ¤íŠ¸ í…ìŠ¤ì²˜ ìƒì„±
            const canvas = document.createElement('canvas');
            canvas.width = 256; // í•´ìƒë„ ì¦ê°€
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // ê²€ì€ìƒ‰ ë°°ê²½ ì¶”ê°€ (ëŒ€ë¹„ í–¥ìƒ)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 256, 256);
            
            // í°ìƒ‰ í…Œë‘ë¦¬ ì¶”ê°€
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 8;
            ctx.font = 'bold 120px Arial'; // í°íŠ¸ í¬ê¸° ì¦ê°€
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeText(symbolText, 128, 128);
            
            // í°ìƒ‰ í…ìŠ¤íŠ¸
            ctx.fillStyle = 'white';
            ctx.fillText(symbolText, 128, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            const symbolMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                alphaTest: 0.1
            });
            
            const symbolMesh = new THREE.Mesh(symbolGeometry, symbolMaterial);
            symbolMesh.position.set(0, 0.6, 0);
            symbolMesh.rotation.x = -Math.PI / 2;
            tileMesh.add(symbolMesh);
        }
        
        // ì´ë²¤íŠ¸ ë¸”ë¡ íš¨ê³¼ ì²˜ë¦¬
        function handleEventBlock(eventBlockType) {
            console.log('ì´ë²¤íŠ¸ ë¸”ë¡ íš¨ê³¼ ë°œë™:', eventBlockType); // ë””ë²„ê¹…ìš©
            
            switch(eventBlockType) {
                case EVENT_BLOCK_TYPES.TIME_GAIN:
                    gameData.time += EVENT_BLOCK_CONFIG.TIME_GAIN_AMOUNT;
                    console.log('ì‹œê°„ +5ì´ˆ íšë“! í˜„ì¬ ì‹œê°„:', gameData.time);
                    createParticleEffect('time_gain');
                    break;
                case EVENT_BLOCK_TYPES.TIME_LOSS:
                    gameData.time -= EVENT_BLOCK_CONFIG.TIME_LOSS_AMOUNT;
                    if (gameData.time < 0) gameData.time = 0;
                    console.log('ì‹œê°„ -5ì´ˆ ì†ì‹¤! í˜„ì¬ ì‹œê°„:', gameData.time);
                    createParticleEffect('time_loss');
                    break;
                case EVENT_BLOCK_TYPES.INVINCIBILITY:
                    gameData.isInvincible = true;
                    gameData.invincibilityEndTime = Date.now() + (EVENT_BLOCK_CONFIG.INVINCIBILITY_DURATION * 1000);
                    console.log('ë¬´ì  ìƒíƒœ í™œì„±í™”! 5ì´ˆê°„ ì§€ì†');
                    createParticleEffect('invincibility');
                    activateInvincibilityEffect();
                    break;
            }
        }
        
        // ë¬´ì  íš¨ê³¼ ì‹œê°í™”
        function activateInvincibilityEffect() {
            if (player && player.mesh) {
                player.mesh.material.emissive.setHex(0xffff00);
                player.mesh.material.emissiveIntensity = 0.8;
                console.log('ë¬´ì  íš¨ê³¼ í™œì„±í™”ë¨'); // ë””ë²„ê¹…ìš©
                
                // ë¬´ì  íƒ€ì´ë¨¸ UI í‘œì‹œ
                invincibilityTimer.style.display = 'block';
                updateInvincibilityTimer();
            }
        }
        
        // ë¬´ì  íš¨ê³¼ í•´ì œ
        function deactivateInvincibilityEffect() {
            if (player && player.mesh) {
                player.mesh.material.emissive.setHex(0x000000);
                player.mesh.material.emissiveIntensity = 0;
                console.log('ë¬´ì  íš¨ê³¼ í•´ì œë¨'); // ë””ë²„ê¹…ìš©
                
                // ë¬´ì  íƒ€ì´ë¨¸ UI ìˆ¨ê¸°ê¸°
                invincibilityTimer.style.display = 'none';
            }
        }
        
        // ë¬´ì  íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        function updateInvincibilityTimer() {
            if (gameData.isInvincible) {
                const remaining = Math.max(0, (gameData.invincibilityEndTime - Date.now()) / 1000);
                invincibilityCountdown.textContent = Math.ceil(remaining);
                
                if (remaining > 0) {
                    setTimeout(updateInvincibilityTimer, 100);
                }
            }
        }
        
        // íŒŒí‹°í´ íš¨ê³¼ ìƒì„±
        function createParticleEffect(type, position) {
            if (!player) return; // í”Œë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ íŒŒí‹°í´ ìƒì„± ì•ˆí•¨
            
            const particleGroup = new THREE.Group();
            const particleCount = type === 'success' ? 20 : 30; // ì„±ê³µ íš¨ê³¼ëŠ” ì ì€ íŒŒí‹°í´
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8); // í¬ê¸° ì¦ê°€
                let particleMaterial;
                
                switch(type) {
                    case 'time_gain':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x00ff00, 
                            transparent: true,
                            emissive: 0x00ff00,
                            emissiveIntensity: 0.5
                        });
                        break;
                    case 'time_loss':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xff0000, 
                            transparent: true,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.5
                        });
                        break;
                    case 'invincibility':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xffff00, 
                            transparent: true,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.5
                        });
                        break;
                    case 'success':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xffffff, 
                            transparent: true,
                            emissive: 0xffffff,
                            emissiveIntensity: 0.8
                        });
                        break;
                }
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // ìœ„ì¹˜ ì„¤ì • (positionì´ ì œê³µë˜ë©´ ì‚¬ìš©, ì•„ë‹ˆë©´ í”Œë ˆì´ì–´ ìœ„ì¹˜)
                const basePos = position || player.mesh.position;
                particle.position.copy(basePos);
                particle.position.y += 2; // ìœ„ìª½ì—ì„œ ì‹œì‘
                
                if (type === 'success') {
                    // ì„±ê³µ íš¨ê³¼ëŠ” ë” í™”ë ¤í•˜ê²Œ
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 12 + 3,
                        (Math.random() - 0.5) * 10
                    );
                } else {
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 15,
                        Math.random() * 8 + 2,
                        (Math.random() - 0.5) * 15
                    );
                }
                
                particle.life = type === 'success' ? 1.5 : 2.0;
                particleGroup.add(particle);
            }
            
            scene.add(particleGroup);
            
            // íŒŒí‹°í´ ì• ë‹ˆë©”ì´ì…˜
            const animateParticles = () => {
                particleGroup.children.forEach(particle => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(0.03));
                    particle.velocity.y -= 0.3; // ì¤‘ë ¥ ì¦ê°€
                    particle.life -= 0.03;
                    particle.material.opacity = particle.life / (type === 'success' ? 1.5 : 2.0);
                    
                    if (particle.life <= 0) {
                        particleGroup.remove(particle);
                    }
                });
                
                if (particleGroup.children.length > 0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particleGroup);
                }
            };
            
            animateParticles();
        }

        const hud = document.getElementById('hud');
        const mainMenu = document.getElementById('main-menu');
        const gameOverPanel = document.getElementById('game-over-panel');
        const settingsPanel = document.getElementById('settings-panel');
        const pausePanel = document.getElementById('pause-panel');
        const scoreDisplay = document.getElementById('score-display');
        const comboDisplay = document.getElementById('combo-display');
        const timeDisplay = document.getElementById('time-display');
        const timeBar = document.getElementById('time-bar');
        const missionDisplay = document.getElementById('mission-display');
        const highScoreDisplay = document.getElementById('high-score');
        const finalScoreDisplay = document.getElementById('final-score');
        const sparksEarnedDisplay = document.getElementById('sparks-earned');
        const newHighScoreBadge = gameOverPanel.querySelector('.new-highscore');
        const virtualKeyboard = document.getElementById('virtual-keyboard');
        const keyboardToggle = document.getElementById('virtual-keyboard-toggle');
        const invincibilityTimer = document.getElementById('invincibility-timer');
        const invincibilityCountdown = document.getElementById('invincibility-countdown');
        const tutorialOverlay = document.getElementById('tutorial-overlay');
        const tutorialTitle = document.getElementById('tutorial-title');
        const tutorialDescription = document.getElementById('tutorial-description');
        const tutorialProgress = document.getElementById('tutorial-progress');
        const tutorialPrevBtn = document.getElementById('tutorial-prev');
        const tutorialNextBtn = document.getElementById('tutorial-next');
        const tutorialSkipBtn = document.getElementById('tutorial-skip');
        const playerLevelDisplay = document.getElementById('player-level');
        const expBar = document.getElementById('exp-bar');
        const expDisplay = document.getElementById('exp-display');
        const expNeededDisplay = document.getElementById('exp-needed');

        function init() {
            scene.background = new THREE.Color(0x121212);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(30, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            const groundGeometry = new THREE.PlaneGeometry(5000, 5000);
            const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.51;
            ground.receiveShadow = true;
            scene.add(ground);

            loadGameData();
            setupSettingsPanel();
            setupVirtualKeyboard();
            applyTheme();

            // UI ë²„íŠ¼ì— í„°ì¹˜ í”¼ë“œë°± ì ìš©
            addTouchFeedback(document.getElementById('start-button'), startGame);
            addTouchFeedback(document.getElementById('tutorial-button'), startTutorial);
            addTouchFeedback(document.getElementById('settings-button'), showSettingsPanel);
            addTouchFeedback(document.getElementById('back-to-menu-button'), showMainMenu);
            addTouchFeedback(document.getElementById('restart-button'), startGame);
            addTouchFeedback(document.getElementById('pause-button'), togglePause);
            addTouchFeedback(document.getElementById('resume-button'), togglePause);
            addTouchFeedback(document.getElementById('home-button'), goHome);
            
            // íŠœí† ë¦¬ì–¼ ë²„íŠ¼ ì´ë²¤íŠ¸ (í„°ì¹˜ í”¼ë“œë°± ì¶”ê°€)
            addTouchFeedback(tutorialPrevBtn, previousTutorialStep);
            addTouchFeedback(tutorialNextBtn, nextTutorialStep);
            addTouchFeedback(tutorialSkipBtn, exitTutorial);
            
            window.addEventListener('keydown', handleInput);
            window.addEventListener('resize', () => {
                onWindowResize();
                updateVirtualKeyboard();
            });

            onWindowResize();
            updateVirtualKeyboard(); // ì´ˆê¸°í™” ì‹œ ê°€ìƒ í‚¤ë³´ë“œ ìƒíƒœ ì—…ë°ì´íŠ¸
            animate();
        }

        function isMobileDevice() {
            const widthCheck = window.innerWidth <= 768;
            const userAgentCheck = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const result = widthCheck || userAgentCheck;
            
            console.log('ëª¨ë°”ì¼ ê°ì§€:', {
                windowWidth: window.innerWidth,
                widthCheck: widthCheck,
                userAgent: navigator.userAgent,
                userAgentCheck: userAgentCheck,
                finalResult: result
            });
            
            return result;
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            renderer.setSize(width, height);
            
            // ëª¨ë°”ì¼ ìµœì í™”: í™”ë©´ í¬ê¸°ì— ë”°ë¼ ì¤Œ ë ˆë²¨ ì¡°ì •
            const zoom = isMobileDevice() ? 0.035 : 0.025; // ëª¨ë°”ì¼ì—ì„œëŠ” ë” ë„“ê²Œ
            
            camera.left = -width * zoom; camera.right = width * zoom;
            camera.top = height * zoom; camera.bottom = -height * zoom;
            camera.updateProjectionMatrix();
        }

        function loadGameData() {
            const savedData = localStorage.getItem('chromaStepData');
            console.log('ì„¤ì • ë¡œë“œ:', savedData);
            
            if (savedData) {
                const parsed = JSON.parse(savedData);
                gameData.highScore = parsed.highScore || 0;
                gameData.colorSparks = parsed.colorSparks || 0;
                gameData.totalScore = parsed.totalScore || 0;
                gameData.level = parsed.level || 1;
                gameData.currentSkin = parsed.currentSkin || 'basic';
                gameData.achievements = parsed.achievements || {};
                gameSettings.theme = parsed.theme || 'ì„ ëª…í•œ ë¬´ì§€ê°œ';
                gameSettings.showVirtualKeyboard = parsed.showVirtualKeyboard !== undefined ? parsed.showVirtualKeyboard : true;
            } else {
                console.log('ì €ì¥ëœ ì„¤ì •ì´ ì—†ìŒ, ê¸°ë³¸ê°’ ì‚¬ìš©');
                gameSettings.showVirtualKeyboard = true;
            }
            
            // ì„ì‹œ: ê°€ìƒ í‚¤ë³´ë“œ ê°•ì œ í™œì„±í™” (í…ŒìŠ¤íŠ¸ìš©)
            console.log('ì›ë˜ ì„¤ì •:', gameSettings.showVirtualKeyboard);
            gameSettings.showVirtualKeyboard = true;
            console.log('ê°•ì œ ì„¤ì • í›„:', gameSettings.showVirtualKeyboard);
            
            // ì§„í–‰ë„ ì—…ë°ì´íŠ¸
            updateProgressDisplay();
            
            console.log('ìµœì¢… ì„¤ì •:', gameSettings);
        }

        function saveGameData() {
            localStorage.setItem('chromaStepData', JSON.stringify({
                highScore: gameData.highScore,
                colorSparks: gameData.colorSparks,
                totalScore: gameData.totalScore,
                level: gameData.level,
                currentSkin: gameData.currentSkin,
                achievements: gameData.achievements,
                theme: gameSettings.theme,
                showVirtualKeyboard: gameSettings.showVirtualKeyboard
            }));
        }

        function showSettingsPanel() {
            mainMenu.style.display = 'none';
            settingsPanel.style.display = 'flex';
        }
        function showMainMenu() {
            settingsPanel.style.display = 'none';
            mainMenu.style.display = 'flex';
        }
        function setupSettingsPanel() {
            const container = document.getElementById('theme-container');
            container.innerHTML = '';
            Object.keys(COLOR_THEMES).forEach(themeName => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'theme-option';

                const button = document.createElement('button');
                button.className = 'ui-button theme-button';
                button.textContent = themeName;
                if (themeName === gameSettings.theme) {
                    button.classList.add('selected');
                }
                button.addEventListener('click', () => {
                    gameSettings.theme = themeName;
                    applyTheme();
                    saveGameData();
                    container.querySelectorAll('.theme-button').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                });

                const previewDiv = document.createElement('div');
                previewDiv.className = 'theme-preview';
                COLOR_THEMES[themeName].forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'theme-swatch';
                    swatch.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}`;
                    previewDiv.appendChild(swatch);
                });
                
                optionDiv.appendChild(button);
                optionDiv.appendChild(previewDiv);
                container.appendChild(optionDiv);
            });
            
            // ê°€ìƒ í‚¤ë³´ë“œ ì²´í¬ë°•ìŠ¤ ìƒíƒœ ì„¤ì •
            console.log('ì²´í¬ë°•ìŠ¤ ì„¤ì •:', gameSettings.showVirtualKeyboard);
            keyboardToggle.checked = gameSettings.showVirtualKeyboard;
        }
        function applyTheme() {
            currentThemeColors = COLOR_THEMES[gameSettings.theme];
        }

        function clearAllTimeouts() {
            // ëª¨ë“  íƒ€ì¼ì˜ íƒ€ì„ì•„ì›ƒì„ ì •ë¦¬
            for (const tile of tiles.values()) {
                if (tile.reactivationTimeout) {
                    clearTimeout(tile.reactivationTimeout);
                    tile.reactivationTimeout = null;
                }
            }
        }

        function updateVirtualKeyboard() {
            const isMobile = isMobileDevice();
            const showKeyboard = gameSettings.showVirtualKeyboard;
            const isPlaying = gameState === 'PLAYING';
            
            console.log('=== ê°€ìƒ í‚¤ë³´ë“œ ë””ë²„ê¹… ===');
            console.log('isMobile:', isMobile);
            console.log('showKeyboard:', showKeyboard);
            console.log('isPlaying:', isPlaying);
            console.log('virtualKeyboard element:', virtualKeyboard);
            
            // CSS ìš°ì„ ìˆœìœ„ ë¬¸ì œ í•´ê²°: ì¸ë¼ì¸ ìŠ¤íƒ€ì¼ ì œê±°
            virtualKeyboard.style.display = '';
            
            if (isMobile && showKeyboard && isPlaying) {
                virtualKeyboard.classList.add('show');
                console.log('âœ… í‚¤ë³´ë“œ í‘œì‹œ ì¡°ê±´ ë§Œì¡± - í‘œì‹œí•¨');
            } else {
                virtualKeyboard.classList.remove('show');
                console.log('âŒ í‚¤ë³´ë“œ í‘œì‹œ ì¡°ê±´ ë¶ˆë§Œì¡± - ìˆ¨ê¹€');
                console.log('ì¡°ê±´ ì²´í¬: isMobile &&', isMobile, '&& showKeyboard &&', showKeyboard, '&& isPlaying &&', isPlaying);
            }
            
            console.log('ìµœì¢… classList:', virtualKeyboard.classList);
        }

        // í–…í‹± í”¼ë“œë°± í•¨ìˆ˜
        function vibrate(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        // ì½¤ë³´ ì‹œê°ì  í”¼ë“œë°± í•¨ìˆ˜
        function triggerComboFeedback(comboValue) {
            // ì½¤ë³´ í‘œì‹œ ì• ë‹ˆë©”ì´ì…˜
            const comboDisplay = document.getElementById('combo-display');
            comboDisplay.classList.remove('combo-boost');
            void comboDisplay.offsetWidth; // ê°•ì œ ë¦¬í”Œë¡œìš°ë¡œ ì• ë‹ˆë©”ì´ì…˜ ì¬ì‹œì‘
            comboDisplay.classList.add('combo-boost');
            
            // ì½¤ë³´ê°€ ë†’ì„ìˆ˜ë¡ ë” ê°•í•œ íš¨ê³¼
            if (comboValue >= 5) {
                // í™”ë©´ í”Œë˜ì‹œ íš¨ê³¼
                const canvasContainer = document.getElementById('canvas-container');
                canvasContainer.classList.remove('screen-flash');
                void canvasContainer.offsetWidth;
                canvasContainer.classList.add('screen-flash');
                
                // ì¹´ë©”ë¼ í”ë“¤ë¦¼ íš¨ê³¼ (ê°„ë‹¨í•œ êµ¬í˜„)
                if (camera) {
                    const originalY = camera.position.y;
                    camera.position.y += Math.random() * 2 - 1;
                    setTimeout(() => {
                        camera.position.y = originalY;
                    }, 100);
                }
            }
            
            // ë†’ì€ ì½¤ë³´ì—ì„œ ë” ê°•í•œ ì§„ë™
            if (comboValue >= 10) {
                vibrate([50, 30, 50, 30, 50]);
            } else if (comboValue >= 5) {
                vibrate([80, 50, 80]);
            }
        }
        
        // íƒ€ì¼ ì„±ê³µ ì‹œê°ì  íš¨ê³¼
        function triggerTileSuccessEffect(tilePosition) {
            // íŒŒí‹°í´ íš¨ê³¼ëŠ” ê¸°ì¡´ í•¨ìˆ˜ í™œìš©
            createParticleEffect('success', tilePosition);
            
            // í”Œë ˆì´ì–´ ë°”ìš´ìŠ¤ íš¨ê³¼
            if (player && player.mesh) {
                const originalY = player.mesh.position.y;
                const bounceHeight = 3;
                const duration = 400; // ë°€ë¦¬ì´ˆ
                const startTime = Date.now();
                
                const animateBounce = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ì‚¬ì¸ í•¨ìˆ˜ë¡œ ìì—°ìŠ¤ëŸ¬ìš´ ë°”ìš´ìŠ¤
                    const bounceY = Math.sin(progress * Math.PI) * bounceHeight;
                    player.mesh.position.y = originalY + bounceY;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateBounce);
                    } else {
                        player.mesh.position.y = originalY; // ì›ë˜ ìœ„ì¹˜ë¡œ ë³µì›
                    }
                };
                
                animateBounce();
            }
        }

        // ë„ì „ê³¼ì œ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
        function checkAchievements() {
            for (const [id, achievement] of Object.entries(ACHIEVEMENTS)) {
                if (gameData.achievements[id]) continue; // ì´ë¯¸ ë‹¬ì„±ëœ ë„ì „ê³¼ì œëŠ” ê±´ë„ˆë›°ê¸°
                
                let isAchieved = false;
                
                switch (id) {
                    case 'first_steps':
                        isAchieved = gameData.sessionStats.tilesPressed >= achievement.target;
                        break;
                    case 'combo_starter':
                    case 'combo_master':
                    case 'combo_legend':
                        isAchieved = gameData.sessionStats.maxCombo >= achievement.target;
                        break;
                    case 'score_hunter':
                    case 'score_champion':
                        isAchieved = gameData.score >= achievement.target;
                        break;
                    case 'time_survivor':
                        isAchieved = gameData.sessionStats.survivalTime >= achievement.target;
                        break;
                    case 'special_collector':
                        isAchieved = gameData.sessionStats.specialBlocksCollected >= achievement.target;
                        break;
                }
                
                if (isAchieved) {
                    unlockAchievement(id, achievement);
                }
            }
        }

        function unlockAchievement(id, achievement) {
            gameData.achievements[id] = true;
            gameData.totalScore += achievement.reward;
            
            showAchievementNotification(achievement);
            vibrate([50, 100, 50, 100, 150]); // ë„ì „ê³¼ì œ ë‹¬ì„± ì§„ë™
            
            // ë ˆë²¨ ì²´í¬ (ë³´ìƒ ì ìˆ˜ë¡œ ì¸í•œ)
            const oldLevel = gameData.level;
            gameData.level = calculateLevel(gameData.totalScore);
            if (gameData.level > oldLevel) {
                showLevelUpNotification(gameData.level);
            }
            
            updateProgressDisplay();
        }

        function showAchievementNotification(achievement) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 120px; left: 50%; transform: translateX(-50%);
                z-index: 9999; background: linear-gradient(45deg, #ff6b35, #f7931e);
                color: white; padding: 12px 25px; border-radius: 20px;
                font-size: 1.1rem; font-weight: bold; text-align: center;
                box-shadow: 0 4px 20px rgba(255, 107, 53, 0.5);
                animation: fadeIn 0.5s ease-out;
                max-width: 300px; word-wrap: break-word;
            `;
            notification.innerHTML = `
                ğŸ† ë„ì „ê³¼ì œ ë‹¬ì„±!<br>
                <span style="font-size: 1rem;">${achievement.name}</span><br>
                <span style="font-size: 0.9rem; opacity: 0.9;">+${achievement.reward} EXP</span>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 4000);
        }

        // ì‹œê°„ ê¸°ë°˜ ë¯¸ì…˜ ì²´í¬
        function checkTimeBasedMissions() {
            const currentMission = gameData.currentMission[0];
            if (!currentMission || currentMission.type !== MISSION_TYPES.TIME_RUSH) return;
            
            const elapsed = Date.now() - currentMission.startTime;
            if (elapsed > currentMission.timeLimit) {
                // íƒ€ì„ ëŸ¬ì‹œ ì‹¤íŒ¨
                showMissionFailedEffect('ì‹œê°„ ì´ˆê³¼!');
                gameData.currentMission.shift();
                addNewMission();
                ensureMissionTileExists();
                updateMissionUI();
                
                // ì½¤ë³´ ë¦¬ì…‹ ë° í˜ë„í‹°
                gameData.combo = 1;
                gameData.time -= 3; // 3ì´ˆ í˜ë„í‹°
                vibrate([200, 100, 200, 100, 200]);
            } else {
                // UI ì—…ë°ì´íŠ¸ (íƒ€ì´ë¨¸)
                updateMissionUI();
            }
        }
        
        function showMissionFailedEffect(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                z-index: 9999; background: linear-gradient(45deg, #ff4444, #cc0000);
                color: white; padding: 15px 30px; border-radius: 20px;
                font-size: 1.3rem; font-weight: bold; text-align: center;
                box-shadow: 0 8px 30px rgba(255, 68, 68, 0.5);
                animation: fadeIn 0.3s ease-out;
                pointer-events: none;
            `;
            notification.innerHTML = `
                <div style="font-size: 1.5rem; margin-bottom: 5px;">âŒ</div>
                <div>${message}</div>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 1500);
        }

        function updateSessionStats() {
            // ì„¸ì…˜ ì¤‘ ìµœëŒ€ ì½¤ë³´ ì—…ë°ì´íŠ¸
            if (gameData.combo > gameData.sessionStats.maxCombo) {
                gameData.sessionStats.maxCombo = gameData.combo;
            }
            
            // ìƒì¡´ ì‹œê°„ ì—…ë°ì´íŠ¸ (ì‹œì‘ ì‹œê°„ - í˜„ì¬ ì‹œê°„)
            gameData.sessionStats.survivalTime = GAME_CONFIG.INITIAL_TIME - gameData.time;
        }

        // ë ˆë²¨ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
        function calculateLevel(totalScore) {
            for (let i = REWARD_SYSTEM.levels.length - 1; i >= 0; i--) {
                if (totalScore >= REWARD_SYSTEM.levels[i]) {
                    return i + 1;
                }
            }
            return 1;
        }

        function getExpForNextLevel(level) {
            if (level >= REWARD_SYSTEM.levels.length) {
                return REWARD_SYSTEM.levels[REWARD_SYSTEM.levels.length - 1];
            }
            return REWARD_SYSTEM.levels[level];
        }

        function updatePlayerProgress(scoreGained) {
            const oldLevel = gameData.level;
            gameData.totalScore += scoreGained;
            gameData.level = calculateLevel(gameData.totalScore);
            
            // ë ˆë²¨ì—… ì²´í¬
            if (gameData.level > oldLevel) {
                showLevelUpNotification(gameData.level);
                vibrate([100, 50, 100, 50, 200]); // ë ˆë²¨ì—… ì§„ë™
                
                // ìƒˆë¡œìš´ ìŠ¤í‚¨ ì–¸ë½ ì²´í¬
                const unlockedSkins = REWARD_SYSTEM.skins.filter(skin => 
                    skin.unlockLevel === gameData.level
                );
                if (unlockedSkins.length > 0) {
                    showSkinUnlockNotification(unlockedSkins[0]);
                }
            }
            
            updateProgressDisplay();
        }

        function updateProgressDisplay() {
            if (!playerLevelDisplay) return;
            
            playerLevelDisplay.textContent = gameData.level;
            
            const currentLevelReq = REWARD_SYSTEM.levels[gameData.level - 1] || 0;
            const nextLevelReq = getExpForNextLevel(gameData.level);
            const progress = gameData.totalScore - currentLevelReq;
            const needed = nextLevelReq - currentLevelReq;
            
            if (expDisplay) expDisplay.textContent = progress;
            if (expNeededDisplay) expNeededDisplay.textContent = needed;
            
            if (expBar) {
                const percentage = Math.min((progress / needed) * 100, 100);
                expBar.style.width = `${percentage}%`;
            }
        }

        function showLevelUpNotification(newLevel) {
            // ê°„ë‹¨í•œ ë ˆë²¨ì—… ì•Œë¦¼ (í™”ë©´ ìƒë‹¨ì— í‘œì‹œ)
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                z-index: 9999; background: linear-gradient(45deg, var(--color-cyan), var(--color-yellow));
                color: black; padding: 15px 30px; border-radius: 25px;
                font-size: 1.3rem; font-weight: bold; text-align: center;
                box-shadow: 0 4px 20px rgba(0, 255, 255, 0.5);
                animation: fadeIn 0.5s ease-out;
            `;
            notification.textContent = `ğŸ‰ ë ˆë²¨ ${newLevel} ë‹¬ì„±! ğŸ‰`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }

        function showSkinUnlockNotification(skin) {
            // ìŠ¤í‚¨ ì–¸ë½ ì•Œë¦¼
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
                z-index: 9999; background: rgba(0, 0, 0, 0.9);
                color: var(--color-yellow); padding: 12px 25px; border-radius: 20px;
                font-size: 1.1rem; font-weight: bold; text-align: center;
                border: 2px solid var(--color-yellow);
                animation: fadeIn 0.5s ease-out;
            `;
            notification.textContent = `âœ¨ ${skin.name} ìŠ¤í‚¨ ì–¸ë½! âœ¨`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }

        function applySkinToPlayer() {
            if (!player || !player.mesh) return;
            
            const currentSkin = REWARD_SYSTEM.skins.find(skin => skin.id === gameData.currentSkin);
            if (currentSkin) {
                player.mesh.material.color.setHex(currentSkin.color);
                // íŠ¹ë³„í•œ íš¨ê³¼ë“¤
                if (currentSkin.id === 'rainbow') {
                    // ë¬´ì§€ê°œ íš¨ê³¼ëŠ” ì‹œê°„ì— ë”°ë¼ ìƒ‰ìƒ ë³€í™”
                    player.mesh.material.emissive.setHex(0x404040);
                    player.mesh.material.emissiveIntensity = 0.3;
                } else if (currentSkin.id === 'crystal') {
                    // í¬ë¦¬ìŠ¤íƒˆ íš¨ê³¼
                    player.mesh.material.transparent = true;
                    player.mesh.material.opacity = 0.8;
                    player.mesh.material.emissive.setHex(currentSkin.color);
                    player.mesh.material.emissiveIntensity = 0.2;
                }
            }
        }

        // í„°ì¹˜ í”¼ë“œë°± í•¨ìˆ˜
        function addTouchFeedback(element, callback, vibrationPattern = [50]) {
            let touchStarted = false;
            
            // í„°ì¹˜ ì‹œì‘
            element.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStarted = true;
                element.style.transform = 'scale(0.95)';
                element.style.filter = 'brightness(1.2)';
                vibrate(vibrationPattern);
            }, { passive: false });
            
            // í„°ì¹˜ ë
            element.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (touchStarted) {
                    element.style.transform = '';
                    element.style.filter = '';
                    callback();
                    touchStarted = false;
                }
            }, { passive: false });
            
            // í„°ì¹˜ ì·¨ì†Œ (í™”ë©´ ë°–ìœ¼ë¡œ ë“œë˜ê·¸ ë“±)
            element.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                element.style.transform = '';
                element.style.filter = '';
                touchStarted = false;
            }, { passive: false });
            
            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë„ ìœ ì§€ (ë°ìŠ¤í¬í†± í˜¸í™˜ì„±)
            element.addEventListener('click', callback);
        }

        function setupVirtualKeyboard() {
            // ê°€ìƒ í‚¤ë³´ë“œ ë²„íŠ¼ ì´ë²¤íŠ¸ ì„¤ì • (í„°ì¹˜ ìµœì í™”)
            const keyUp = document.getElementById('key-up');
            const keyDown = document.getElementById('key-down');
            const keyLeft = document.getElementById('key-left');
            const keyRight = document.getElementById('key-right');
            
            if (keyUp) addTouchFeedback(keyUp, () => handleVirtualKey('ArrowUp'), [30]);
            if (keyDown) addTouchFeedback(keyDown, () => handleVirtualKey('ArrowDown'), [30]);
            if (keyLeft) addTouchFeedback(keyLeft, () => handleVirtualKey('ArrowLeft'), [30]);
            if (keyRight) addTouchFeedback(keyRight, () => handleVirtualKey('ArrowRight'), [30]);
            
            // ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸ ì„¤ì •
            if (keyboardToggle) {
                keyboardToggle.addEventListener('change', (e) => {
                    console.log('ì²´í¬ë°•ìŠ¤ ë³€ê²½:', e.target.checked);
                    gameSettings.showVirtualKeyboard = e.target.checked;
                    updateVirtualKeyboard();
                    saveGameData();
                });
            } else {
                console.log('âš ï¸ ì²´í¬ë°•ìŠ¤ ì—˜ë¦¬ë¨¼íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤!');
            }
        }

        function handleVirtualKey(key) {
            if (gameState !== 'PLAYING') return;
            
            // ë²„íŠ¼ ëˆ„ë¦„ íš¨ê³¼
            const button = document.getElementById(`key-${key.replace('Arrow', '').toLowerCase()}`);
            if (button) {
                button.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    button.style.transform = '';
                }, 100);
            }
            
            // í‚¤ ì…ë ¥ ì‹œë®¬ë ˆì´ì…˜
            handleInput({ key: key });
        }

        function startGame() {
            mainMenu.style.display = 'none';
            gameOverPanel.style.display = 'none';
            pausePanel.style.display = 'none';
            hud.style.display = 'flex';
            missionDisplay.style.display = 'flex';
            document.getElementById('pause-button').textContent = '||';

            gameData.score = 0;
            gameData.time = GAME_CONFIG.INITIAL_TIME;
            gameData.combo = 1;
            gameData.currentMission = [];
            
            // ì„¸ì…˜ í†µê³„ ì´ˆê¸°í™”
            gameData.sessionStats = {
                tilesPressed: 0,
                maxCombo: 0,
                specialBlocksCollected: 0,
                survivalTime: 0
            };
            
            // í™•ì¥ëœ ë¯¸ì…˜ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            gameData.missionProgress = [];
            gameData.rainbowProgress = new Set();
            gameData.timeRushStartTime = 0;
            gameData.missionStartTime = Date.now();
            
            // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€: ëª¨ë“  íƒ€ì„ì•„ì›ƒ ì •ë¦¬
            clearAllTimeouts();
            
            tiles.forEach(tile => scene.remove(tile.mesh));
            tiles.clear();
            if (player) scene.remove(player.mesh);

            createPlayer();
            camera.position.set(0, 60, 60);
            cameraTarget.set(0, 0, 0);
            updateCamera();

            for (let i = 0; i < 3; i++) {
                addNewMission();
            }
            updateWorld(); // ì´ë¯¸ ensureMissionTileExistsë¥¼ í˜¸ì¶œí•¨
            
            const startTile = tiles.get('0,0');
            if (startTile && startTile.colorIndex === gameData.currentMission[0]) {
                let newColorIndex;
                do {
                    newColorIndex = Math.floor(Math.random() * currentThemeColors.length);
                } while (newColorIndex === gameData.currentMission[0]);
                startTile.colorIndex = newColorIndex;
                startTile.mesh.material.color.set(currentThemeColors[newColorIndex]);
            }

            gameState = 'PLAYING';
            updateVirtualKeyboard();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            
            // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€: ëª¨ë“  íƒ€ì„ì•„ì›ƒ ì •ë¦¬
            clearAllTimeouts();
            
            hud.style.display = 'none';
            missionDisplay.style.display = 'none';
            gameOverPanel.style.display = 'flex';

            finalScoreDisplay.textContent = gameData.score.toLocaleString();
            if (gameData.score > gameData.highScore) {
                gameData.highScore = gameData.score;
                newHighScoreBadge.style.display = 'block';
            } else {
                newHighScoreBadge.style.display = 'none';
            }
            
            const sparks = Math.floor(gameData.score / 100);
            sparksEarnedDisplay.textContent = sparks.toLocaleString();
            gameData.colorSparks += sparks;
            
            // ì§„í–‰ë„ ì—…ë°ì´íŠ¸ (í˜„ì¬ ê²Œì„ ì ìˆ˜ë¡œ)
            updatePlayerProgress(gameData.score);
            
            saveGameData();
            highScoreDisplay.textContent = gameData.highScore.toLocaleString();
            updateVirtualKeyboard();
        }

        function update(deltaTime) {
            if (gameState !== 'PLAYING' || !player) return;

            // ë™ì  ì‹œê°„ ê°ì†Œ (ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ë” ë¹ ë¥´ê²Œ ê°ì†Œ)
            const elapsedTime = GAME_CONFIG.INITIAL_TIME - gameData.time;
            const difficultyMultiplier = 1 + (elapsedTime / 60) * (GAME_CONFIG.TIME_DECAY_RATE - 1);
            
            gameData.time -= deltaTime * difficultyMultiplier;
            if (gameData.time <= 0) {
                gameData.time = 0;
                gameOver();
            }
            
            // ë¬´ì  ìƒíƒœ í™•ì¸
            if (gameData.isInvincible && Date.now() > gameData.invincibilityEndTime) {
                gameData.isInvincible = false;
                deactivateInvincibilityEffect();
            }
            
            player.mesh.position.lerp(player.targetPosition, 0.2);
            checkPlayerOnTile();
            updateWorld();
            updateUI();
            updateTiles();
            
            // ì„¸ì…˜ í†µê³„ ë° ë„ì „ê³¼ì œ ì—…ë°ì´íŠ¸
            updateSessionStats();
            
            // íƒ€ì„ ëŸ¬ì‹œ ë¯¸ì…˜ ì‹œê°„ ì²´í¬
            checkTimeBasedMissions();
            
            // ì£¼ê¸°ì ìœ¼ë¡œ ë„ì „ê³¼ì œ ì²´í¬ (ì‹œê°„ ê¸°ë°˜ ë„ì „ê³¼ì œ ë“±)
            if (Math.floor(gameData.time) !== Math.floor(gameData.time + deltaTime)) {
                checkAchievements();
            }
        }

        function updateUI() {
            scoreDisplay.textContent = `Score: ${gameData.score.toLocaleString()}`;
            const comboBonus = 1.0 + (gameData.combo - 1) * GAME_CONFIG.COMBO_MULTIPLIER;
            comboDisplay.textContent = `Combo: x${Math.min(comboBonus, GAME_CONFIG.MAX_COMBO_BONUS).toFixed(1)}`;
            timeDisplay.textContent = `Time: ${gameData.time.toFixed(1)}`;
            timeBar.style.width = `${(gameData.time / GAME_CONFIG.INITIAL_TIME) * 100}%`;
        }
        
        function createPlayer() {
            const geometry = new THREE.SphereGeometry(GAME_CONFIG.TILE_SIZE * 0.4, 32, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, emissive: 0xcccccc, metalness: 0.1, roughness: 0.2
            });
            const playerY = 0.5 + (GAME_CONFIG.TILE_SIZE * 0.4);
            player = {
                mesh: new THREE.Mesh(geometry, material),
                gridX: 0, gridY: 0,
                targetPosition: new THREE.Vector3(0, playerY, 0)
            };
            player.mesh.castShadow = true;
            player.mesh.position.copy(player.targetPosition);
            scene.add(player.mesh);
            
            // í˜„ì¬ ìŠ¤í‚¨ ì ìš©
            applySkinToPlayer();
        }

        function handleInput(event) {
            if (gameState !== 'PLAYING' && gameState !== 'TUTORIAL') return;
            
            // íŠœí† ë¦¬ì–¼ ìƒíƒœì—ì„œëŠ” í”Œë ˆì´ì–´ ì´ë™ í—ˆìš© ì—¬ë¶€ í™•ì¸
            if (gameState === 'TUTORIAL') {
                const currentStep = tutorialSteps[tutorialData.currentStep];
                if (!currentStep.playerCanMove) return;
            }
            
            let dx = 0, dy = 0;
            switch (event.key) {
                case 'ArrowUp':    dy = 1; break;
                case 'ArrowDown':  dy = -1; break;
                case 'ArrowLeft':  dx = -1; break;
                case 'ArrowRight': dx = 1; break;
                default: return;
            }
            
            const nextGridX = player.gridX + dx;
            const nextGridY = player.gridY + dy;
            const nextTileKey = `${nextGridX},${nextGridY}`;
            const nextTile = tiles.get(nextTileKey);

            // ë¬´ì  ìƒíƒœì¼ ë•ŒëŠ” ë¹„í™œì„±í™”ëœ ë¸”ë¡ ìœ„ë¡œë„ ì´ë™ ê°€ëŠ¥
            if (nextTile && (!nextTile.isDeactivated || gameData.isInvincible)) {
                player.gridX = nextGridX;
                player.gridY = nextGridY;
                const tileSpacing = GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_GAP;
                player.targetPosition.x = player.gridX * tileSpacing;
                player.targetPosition.z = player.gridY * tileSpacing * -1;
                
                // íŠœí† ë¦¬ì–¼ ìƒíƒœì—ì„œ ì´ë™ ì™„ë£Œ í‘œì‹œ
                if (gameState === 'TUTORIAL') {
                    tutorialData.hasPlayerMoved = true;
                    const currentStep = tutorialSteps[tutorialData.currentStep];
                    if (currentStep.autoNext && currentStep.waitForMove) {
                        updateTutorialUI();
                    }
                }
            }
        }
        
        function checkPlayerOnTile() {
            const tileKey = `${player.gridX},${player.gridY}`;
            const currentTile = tiles.get(tileKey);
            
            if (currentTile && !currentTile.isDeactivated) {
                handleStepOnTile(currentTile);
            }
            // ë¬´ì  ìƒíƒœì—ì„œ ë¹„í™œì„±í™”ëœ ë¸”ë¡ ìœ„ì— ìˆì„ ë•ŒëŠ” ì•„ë¬´ íš¨ê³¼ ì—†ìŒ
        }

        function handleStepOnTile(tile) {
            tile.isDeactivated = true; 
            
            // ì„¸ì…˜ í†µê³„ ì—…ë°ì´íŠ¸ (ëª¨ë“  íƒ€ì¼ì— ëŒ€í•´)
            gameData.sessionStats.tilesPressed++;
            
            // ì´ë²¤íŠ¸ ë¸”ë¡ ì²˜ë¦¬
            if (tile.eventBlockType) {
                gameData.sessionStats.specialBlocksCollected++;
                handleEventBlock(tile.eventBlockType);
                deactivateAndScheduleReactivation(tile);
                vibrate([80, 50, 80]); // íŠ¹ìˆ˜ ë¸”ë¡ ì§„ë™ íŒ¨í„´
                
                // ë„ì „ê³¼ì œ ì²´í¬
                checkAchievements();
                return;
            }
            
            const result = checkMissionProgress(tile.colorIndex);

            if (result.success) {
                // ì„±ê³µ ì‹œ í–…í‹± í”¼ë“œë°±
                vibrate([100]);
                
                // ë¯¸ì…˜ ì™„ë£Œ ì‹œ ì¶”ê°€ ë³´ìƒ
                let scoreMultiplier = 1.0;
                if (result.missionCompleted) {
                    scoreMultiplier = MISSION_CONFIGS[result.missionType]?.baseReward / 100 || 1.0;
                    
                    // ë¯¸ì…˜ ì™„ë£Œ ì‹œê°ì  íš¨ê³¼
                    showMissionCompleteEffect(result.missionType);
                }

                gameData.score += Math.round(GAME_CONFIG.BASE_SCORE_PER_TILE * scoreMultiplier * (1.0 + (gameData.combo - 1) * GAME_CONFIG.COMBO_MULTIPLIER));
                gameData.combo++;
                
                // ì½¤ë³´ ì‹œê°ì  í”¼ë“œë°± íŠ¸ë¦¬ê±°
                triggerComboFeedback(gameData.combo);
                
                // íƒ€ì¼ ì„±ê³µ íš¨ê³¼
                triggerTileSuccessEffect(player.mesh.position);
                
                // íŠœí† ë¦¬ì–¼ ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ ì‹œê°„ ì—…ë°ì´íŠ¸
                if (gameState !== 'TUTORIAL') {
                    gameData.time += GAME_CONFIG.TIME_REWARD_BASE * scoreMultiplier;
                }
                
                // íŠœí† ë¦¬ì–¼ ìƒíƒœì—ì„œ ì˜¬ë°”ë¥¸ íƒ€ì¼ ë°Ÿê¸° ì™„ë£Œ í‘œì‹œ
                if (gameState === 'TUTORIAL') {
                    tutorialData.hasSteppedCorrectTile = true;
                    const currentStep = tutorialSteps[tutorialData.currentStep];
                    if (currentStep.autoNext && currentStep.waitForCorrectTile) {
                        updateTutorialUI();
                    }
                }
                
                // ë¯¸ì…˜ ì™„ë£Œ ì‹œ ìƒˆ ë¯¸ì…˜ ìƒì„±
                if (result.missionCompleted) {
                    gameData.currentMission.shift();
                    addNewMission();
                    ensureMissionTileExists();
                }
                
                updateMissionUI();
                
                // ë„ì „ê³¼ì œ ì²´í¬ (ì„±ê³µì ì¸ íƒ€ì¼ ë°Ÿê¸° í›„)
                checkAchievements();
            } else {
                // ì‹¤íŒ¨ ì‹œ í–…í‹± í”¼ë“œë°±
                vibrate([200, 100, 200]);
                gameData.combo = 1;
                
                // ë¯¸ì…˜ ì‹¤íŒ¨ ì‹œ ì§„í–‰ë„ ë¦¬ì…‹ (íŠ¹ì • ë¯¸ì…˜ íƒ€ì…)
                if (result.resetProgress) {
                    resetCurrentMissionProgress();
                }
                
                // íŠœí† ë¦¬ì–¼ ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ ì‹œê°„ í˜ë„í‹°
                if (gameState !== 'TUTORIAL') {
                    gameData.time -= GAME_CONFIG.TIME_PENALTY_PER_MOVE;
                }
                updateMissionUI();
            }
            
            deactivateAndScheduleReactivation(tile);
        }

        // ìƒˆë¡œìš´ ë¯¸ì…˜ ìƒì„± (í™•ì¥ëœ ë²„ì „)
        function generateNewMission() {
            // ë ˆë²¨ì— ë”°ë¥¸ ë¯¸ì…˜ íƒ€ì… í™•ë¥  ì¡°ì •
            const level = gameData.level;
            let missionTypeWeights = {
                [MISSION_TYPES.SINGLE_COLOR]: 60,
                [MISSION_TYPES.DOUBLE]: level >= 2 ? 20 : 0,
                [MISSION_TYPES.SEQUENCE]: level >= 3 ? 15 : 0,
                [MISSION_TYPES.RAINBOW]: level >= 5 ? 10 : 0,
                [MISSION_TYPES.TIME_RUSH]: level >= 4 ? 5 : 0
            };
            
            // ê°€ì¤‘ì¹˜ ê¸°ë°˜ ëœë¤ ì„ íƒ
            const totalWeight = Object.values(missionTypeWeights).reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            
            for (const [type, weight] of Object.entries(missionTypeWeights)) {
                random -= weight;
                if (random <= 0) {
                    return generateMissionOfType(type);
                }
            }
            
            // í´ë°±: ê¸°ë³¸ ë¯¸ì…˜
            return generateMissionOfType(MISSION_TYPES.SINGLE_COLOR);
        }
        
        function generateMissionOfType(missionType) {
            const colors = currentThemeColors;
            
            switch (missionType) {
                case MISSION_TYPES.SINGLE_COLOR:
                    return {
                        type: missionType,
                        target: [Math.floor(Math.random() * colors.length)],
                        progress: 0,
                        maxProgress: 1
                    };
                    
                case MISSION_TYPES.DOUBLE:
                    const colorIndex = Math.floor(Math.random() * colors.length);
                    return {
                        type: missionType,
                        target: [colorIndex, colorIndex],
                        progress: 0,
                        maxProgress: 2
                    };
                    
                case MISSION_TYPES.SEQUENCE:
                    const sequenceLength = 3;
                    const sequence = [];
                    for (let i = 0; i < sequenceLength; i++) {
                        sequence.push(Math.floor(Math.random() * colors.length));
                    }
                    return {
                        type: missionType,
                        target: sequence,
                        progress: 0,
                        maxProgress: sequenceLength
                    };
                    
                case MISSION_TYPES.RAINBOW:
                    return {
                        type: missionType,
                        target: Array.from({length: colors.length}, (_, i) => i),
                        progress: 0,
                        maxProgress: colors.length,
                        collected: new Set()
                    };
                    
                case MISSION_TYPES.TIME_RUSH:
                    return {
                        type: missionType,
                        target: Array.from({length: 3}, () => Math.floor(Math.random() * colors.length)),
                        progress: 0,
                        maxProgress: 3,
                        timeLimit: 5000, // 5ì´ˆ
                        startTime: Date.now()
                    };
                    
                default:
                    return generateMissionOfType(MISSION_TYPES.SINGLE_COLOR);
            }
        }

        // ë¯¸ì…˜ ì§„í–‰ë„ ì²´í¬ í•¨ìˆ˜
        function checkMissionProgress(colorIndex) {
            const currentMission = gameData.currentMission[0];
            if (!currentMission) return { success: false };
            
            switch (currentMission.type) {
                case MISSION_TYPES.SINGLE_COLOR:
                    if (colorIndex === currentMission.target[0]) {
                        return { success: true, missionCompleted: true, missionType: currentMission.type };
                    }
                    break;
                    
                case MISSION_TYPES.DOUBLE:
                    if (colorIndex === currentMission.target[currentMission.progress]) {
                        currentMission.progress++;
                        if (currentMission.progress >= currentMission.maxProgress) {
                            return { success: true, missionCompleted: true, missionType: currentMission.type };
                        }
                        return { success: true, missionCompleted: false };
                    } else {
                        return { success: false, resetProgress: true };
                    }
                    break;
                    
                case MISSION_TYPES.SEQUENCE:
                    if (colorIndex === currentMission.target[currentMission.progress]) {
                        currentMission.progress++;
                        if (currentMission.progress >= currentMission.maxProgress) {
                            return { success: true, missionCompleted: true, missionType: currentMission.type };
                        }
                        return { success: true, missionCompleted: false };
                    } else {
                        return { success: false, resetProgress: true };
                    }
                    break;
                    
                case MISSION_TYPES.RAINBOW:
                    if (currentMission.target.includes(colorIndex) && !currentMission.collected.has(colorIndex)) {
                        currentMission.collected.add(colorIndex);
                        currentMission.progress++;
                        if (currentMission.progress >= currentMission.maxProgress) {
                            return { success: true, missionCompleted: true, missionType: currentMission.type };
                        }
                        return { success: true, missionCompleted: false };
                    }
                    break;
                    
                case MISSION_TYPES.TIME_RUSH:
                    // ì‹œê°„ ì²´í¬
                    const elapsed = Date.now() - currentMission.startTime;
                    if (elapsed > currentMission.timeLimit) {
                        return { success: false, resetProgress: true };
                    }
                    
                    if (currentMission.target.includes(colorIndex)) {
                        // ì´ë¯¸ ë°Ÿì€ ìƒ‰ìƒì¸ì§€ ì²´í¬
                        const targetIndex = currentMission.target.findIndex((color, idx) => 
                            color === colorIndex && idx >= currentMission.progress
                        );
                        
                        if (targetIndex !== -1) {
                            currentMission.progress++;
                            if (currentMission.progress >= currentMission.maxProgress) {
                                return { success: true, missionCompleted: true, missionType: currentMission.type };
                            }
                            return { success: true, missionCompleted: false };
                        }
                    }
                    break;
            }
            
            return { success: false };
        }
        
        function resetCurrentMissionProgress() {
            const currentMission = gameData.currentMission[0];
            if (!currentMission) return;
            
            currentMission.progress = 0;
            if (currentMission.collected) {
                currentMission.collected.clear();
            }
            if (currentMission.type === MISSION_TYPES.TIME_RUSH) {
                currentMission.startTime = Date.now();
            }
        }
        
        function showMissionCompleteEffect(missionType) {
            const config = MISSION_CONFIGS[missionType];
            if (!config) return;
            
            // í™”ë©´ ì¤‘ì•™ì— ë¯¸ì…˜ ì™„ë£Œ ì•Œë¦¼
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                z-index: 9999; background: linear-gradient(45deg, #ff6b35, #f7931e);
                color: white; padding: 20px 40px; border-radius: 25px;
                font-size: 1.5rem; font-weight: bold; text-align: center;
                box-shadow: 0 8px 30px rgba(255, 107, 53, 0.5);
                animation: fadeIn 0.3s ease-out;
                pointer-events: none;
            `;
            notification.innerHTML = `
                <div style="font-size: 2rem; margin-bottom: 10px;">${config.icon}</div>
                <div>${config.name} ì™„ë£Œ!</div>
                <div style="font-size: 1rem; opacity: 0.9;">+${config.baseReward} ì ìˆ˜!</div>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 1500);
            
            // íŠ¹ë³„í•œ ì§„ë™ íŒ¨í„´
            vibrate([100, 50, 100, 50, 200]);
        }

        // ê¸°ì¡´ í•¨ìˆ˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼
        function addNewMission() {
            const newMission = generateNewMission();
            gameData.currentMission.push(newMission);
            gameData.missionStartTime = Date.now();
        }

        function ensureMissionTileExists() {
            const currentMission = gameData.currentMission[0];
            if (!currentMission) return;
            
            const requiredColors = getRequiredColorsForMission(currentMission);
            
            for (const colorIndex of requiredColors) {
                if (!hasAccessibleTileOfColor(colorIndex)) {
                    createTileOfColor(colorIndex);
                }
            }
        }
        
        function getRequiredColorsForMission(mission) {
            switch (mission.type) {
                case MISSION_TYPES.SINGLE_COLOR:
                    return [mission.target[0]];
                    
                case MISSION_TYPES.DOUBLE:
                    return [mission.target[mission.progress]];
                    
                case MISSION_TYPES.SEQUENCE:
                    return [mission.target[mission.progress]];
                    
                case MISSION_TYPES.RAINBOW:
                    return mission.target.filter(color => !mission.collected.has(color));
                    
                case MISSION_TYPES.TIME_RUSH:
                    return mission.target.filter((color, idx) => idx >= mission.progress);
                    
                default:
                    return [];
            }
        }
        
        function hasAccessibleTileOfColor(colorIndex) {
            for (const tile of tiles.values()) {
                if (tile.colorIndex === colorIndex && !tile.isDeactivated) {
                    const distance = Math.sqrt((tile.gridX - player.gridX)**2 + (tile.gridY - player.gridY)**2);
                    if (distance <= 10) { // ì ë‹¹í•œ ê±°ë¦¬ ë‚´ì— ìˆìŒ
                        return true;
                    }
                }
            }
            return false;
        }
        
        function createTileOfColor(colorIndex) {
            // ì ‘ê·¼ ê°€ëŠ¥í•œ íƒ€ì¼ì„ ìš°ì„ ì ìœ¼ë¡œ ì„ íƒ (í”Œë ˆì´ì–´ ì£¼ë³€ íƒ€ì¼)
            const accessibleTiles = [];
            const nearbyTiles = [];
            
            for (const tile of tiles.values()) {
                if (!tile.isDeactivated && !tile.eventBlockType) {
                    const distance = Math.sqrt((tile.gridX - player.gridX)**2 + (tile.gridY - player.gridY)**2);
                    
                    // í”Œë ˆì´ì–´ì™€ ì¸ì ‘í•œ íƒ€ì¼ (ê±°ë¦¬ 1-3)
                    if (distance <= 3 && distance > 0) {
                        accessibleTiles.push(tile);
                    } 
                    // ê·¸ ì™¸ ê·¼ì²˜ íƒ€ì¼ (ê±°ë¦¬ 4-8)
                    else if (distance <= 8 && distance > 3) {
                        nearbyTiles.push(tile);
                    }
                }
            }

            let targetTile = null;
            
            // 1ìˆœìœ„: ì ‘ê·¼ ê°€ëŠ¥í•œ íƒ€ì¼
            if (accessibleTiles.length > 0) {
                targetTile = accessibleTiles[Math.floor(Math.random() * accessibleTiles.length)];
            } 
            // 2ìˆœìœ„: ê·¼ì²˜ íƒ€ì¼
            else if (nearbyTiles.length > 0) {
                targetTile = nearbyTiles[Math.floor(Math.random() * nearbyTiles.length)];
            } 
            // 3ìˆœìœ„: ì•„ë¬´ íƒ€ì¼
            else {
                const allTiles = Array.from(tiles.values()).filter(t => 
                    !t.isDeactivated && 
                    !t.eventBlockType &&
                    (t.gridX !== player.gridX || t.gridY !== player.gridY)
                );
                if (allTiles.length > 0) {
                    targetTile = allTiles[Math.floor(Math.random() * allTiles.length)];
                }
            }

            if (targetTile) {
                targetTile.colorIndex = colorIndex;
                targetTile.mesh.material.color.set(currentThemeColors[colorIndex]);
            }
        }

        function updateWorld() {
            if (!player) return;
            const centerX = player.gridX;
            const centerY = player.gridY;
            const radius = GAME_CONFIG.GRID_RADIUS;

            for (let x = centerX - radius; x <= centerX + radius; x++) {
                for (let y = centerY - radius; y <= centerY + radius; y++) {
                    const dist = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
                    if (dist <= radius) {
                        const tileKey = `${x},${y}`;
                        if (!tiles.has(tileKey)) {
                            createTile(x, y, Math.floor(Math.random() * currentThemeColors.length));
                        }
                    }
                }
            }

            for (const [key, tile] of tiles.entries()) {
                const dist = Math.sqrt((tile.gridX - centerX)**2 + (tile.gridY - centerY)**2);
                if (dist > radius + 3) {
                    // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€: íƒ€ì„ì•„ì›ƒ ì •ë¦¬
                    if (tile.reactivationTimeout) {
                        clearTimeout(tile.reactivationTimeout);
                        tile.reactivationTimeout = null;
                    }
                    scene.remove(tile.mesh);
                    tiles.delete(key);
                }
            }
            
            // ì„±ëŠ¥ ìµœì í™”: ë§¤ 10í”„ë ˆì„ë§ˆë‹¤ ë¯¸ì…˜ íƒ€ì¼ ì²´í¬
            frameCounter++;
            if (frameCounter % 10 === 0) {
                ensureMissionTileExists();
            }
        }

        function createTile(gridX, gridY, colorIndex) {
            const tileKey = `${gridX},${gridY}`;
            if (tiles.has(tileKey)) return;

            // ì´ë²¤íŠ¸ ë¸”ë¡ ìƒì„± í™•ë¥  ì²´í¬
            const eventBlockType = shouldCreateEventBlock();
            
            const geometry = new THREE.BoxGeometry(GAME_CONFIG.TILE_SIZE, 1, GAME_CONFIG.TILE_SIZE);
            let material;
            
            if (eventBlockType) {
                material = new THREE.MeshStandardMaterial({ 
                    color: EVENT_BLOCK_CONFIG.COLORS[eventBlockType],
                    emissive: EVENT_BLOCK_CONFIG.COLORS[eventBlockType],
                    emissiveIntensity: 0.3
                });
            } else {
                material = new THREE.MeshStandardMaterial({ color: currentThemeColors[colorIndex] });
            }
            
            const tileMesh = new THREE.Mesh(geometry, material);
            tileMesh.castShadow = true;

            const tileSpacing = GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_GAP;
            tileMesh.position.set(gridX * tileSpacing, 0, gridY * tileSpacing * -1);

            // ì´ë²¤íŠ¸ ë¸”ë¡ì— ì‹¬ë³¼ ì¶”ê°€
            if (eventBlockType) {
                addEventBlockSymbol(tileMesh, eventBlockType);
            }

            scene.add(tileMesh);
            const tileData = { 
                mesh: tileMesh, gridX, gridY, colorIndex, 
                isDeactivated: false, 
                targetY: 0,
                eventBlockType: eventBlockType || null
            };
            tiles.set(tileKey, tileData);
            return tileData;
        }

        function deactivateAndScheduleReactivation(tile) {
            // íƒ€ì¼ ë°Ÿê¸° ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
            tile.mesh.material.emissive.setHex(0xffffff);
            tile.mesh.material.emissiveIntensity = 0.5;
            
            // ì¦‰ì‹œ ì›ë˜ ìƒ‰ìœ¼ë¡œ ë³µì›í•œ í›„ ì„œì„œíˆ ì–´ë‘¡ê²Œ
            setTimeout(() => {
                tile.mesh.material.emissive.setHex(0x000000);
                tile.mesh.material.emissiveIntensity = 0;
            }, 200);
            
            tile.targetY = -GAME_CONFIG.TILE_SIZE;
            tile.mesh.material.color.set(DEACTIVATED_COLOR);
            tile.mesh.castShadow = false;

            const reactivationTimeout = setTimeout(() => {
                // íŠ¹ìˆ˜ë¸”ë¡ì´ë“  ì¼ë°˜ë¸”ë¡ì´ë“  ì¬í™œì„±í™”ì‹œ í•­ìƒ ì¼ë°˜ ë¸”ë¡ìœ¼ë¡œ ë³µì›
                tile.eventBlockType = null;
                tile.mesh.material.emissive.setHex(0x000000);
                tile.mesh.material.emissiveIntensity = 0;
                
                // ê¸°ì¡´ ì‹¬ë³¼ ì œê±°
                if (tile.mesh.children.length > 0) {
                    tile.mesh.children.forEach(child => tile.mesh.remove(child));
                }
                
                let newColorIndex;
                do {
                    newColorIndex = Math.floor(Math.random() * currentThemeColors.length);
                } while (gameData.currentMission.includes(newColorIndex));
                
                tile.colorIndex = newColorIndex;
                tile.mesh.material.color.set(currentThemeColors[newColorIndex]);
                
                tile.isDeactivated = false;
                tile.targetY = 0;
                tile.mesh.castShadow = true;
                
                // íƒ€ì„ì•„ì›ƒ ì°¸ì¡° ì œê±°
                tile.reactivationTimeout = null;
            }, GAME_CONFIG.TILE_RESPAWN_TIME);
            
            // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ë¥¼ ìœ„í•œ íƒ€ì„ì•„ì›ƒ ì°¸ì¡° ì €ì¥
            tile.reactivationTimeout = reactivationTimeout;
        }

        function updateTiles() {
            for (const tile of tiles.values()) {
                if (tile.mesh.position.y !== tile.targetY) {
                    const newY = THREE.MathUtils.lerp(tile.mesh.position.y, tile.targetY, 0.1);
                    
                    // ì„±ëŠ¥ ìµœì í™”: ëª©í‘œ ìœ„ì¹˜ì— ì¶©ë¶„íˆ ê°€ê¹Œìš°ë©´ ì •í™•í•œ ìœ„ì¹˜ë¡œ ì„¤ì •
                    if (Math.abs(newY - tile.targetY) < 0.01) {
                        tile.mesh.position.y = tile.targetY;
                    } else {
                        tile.mesh.position.y = newY;
                    }
                }
            }
        }

        function updateMissionUI() {
            missionDisplay.innerHTML = '';
            
            const currentMission = gameData.currentMission[0];
            if (!currentMission) return;
            
            // ë¯¸ì…˜ íƒ€ì… í‘œì‹œ
            const typeIndicator = document.createElement('div');
            typeIndicator.style.cssText = `
                font-size: 1.2rem; margin-bottom: 5px; color: var(--color-text);
                text-align: center; font-weight: bold;
            `;
            const config = MISSION_CONFIGS[currentMission.type];
            typeIndicator.textContent = `${config.icon} ${config.name}`;
            missionDisplay.appendChild(typeIndicator);
            
            // ë¯¸ì…˜ë³„ UI í‘œì‹œ
            const missionContainer = document.createElement('div');
            missionContainer.style.cssText = 'display: flex; gap: 6px; align-items: center; justify-content: center;';
            
            switch (currentMission.type) {
                case MISSION_TYPES.SINGLE_COLOR:
                    createColorIndicator(missionContainer, currentMission.target[0], true);
                    break;
                    
                case MISSION_TYPES.DOUBLE:
                    currentMission.target.forEach((colorIndex, idx) => {
                        createColorIndicator(missionContainer, colorIndex, idx === currentMission.progress);
                    });
                    break;
                    
                case MISSION_TYPES.SEQUENCE:
                    currentMission.target.forEach((colorIndex, idx) => {
                        createColorIndicator(missionContainer, colorIndex, idx === currentMission.progress);
                        if (idx < currentMission.target.length - 1) {
                            const arrow = document.createElement('div');
                            arrow.textContent = 'â†’';
                            arrow.style.color = 'var(--color-text)';
                            missionContainer.appendChild(arrow);
                        }
                    });
                    break;
                    
                case MISSION_TYPES.RAINBOW:
                    currentMission.target.forEach(colorIndex => {
                        const isCollected = currentMission.collected.has(colorIndex);
                        createColorIndicator(missionContainer, colorIndex, !isCollected, isCollected);
                    });
                    break;
                    
                case MISSION_TYPES.TIME_RUSH:
                    // íƒ€ì´ë¨¸ í‘œì‹œ
                    const elapsed = Date.now() - currentMission.startTime;
                    const remaining = Math.max(0, currentMission.timeLimit - elapsed);
                    const timerDiv = document.createElement('div');
                    timerDiv.style.cssText = `
                        background: ${remaining < 2000 ? '#ff4444' : '#44ff44'};
                        color: black; padding: 2px 8px; border-radius: 10px;
                        font-size: 0.9rem; font-weight: bold; margin-right: 8px;
                    `;
                    timerDiv.textContent = `${Math.ceil(remaining / 1000)}s`;
                    missionContainer.appendChild(timerDiv);
                    
                    // í•„ìš”í•œ ìƒ‰ìƒë“¤
                    currentMission.target.forEach((colorIndex, idx) => {
                        createColorIndicator(missionContainer, colorIndex, idx === currentMission.progress);
                    });
                    break;
            }
            
            // ì§„í–‰ë„ í‘œì‹œ
            if (currentMission.maxProgress > 1) {
                const progressDiv = document.createElement('div');
                progressDiv.style.cssText = `
                    font-size: 0.8rem; color: var(--color-text);
                    margin-top: 3px; text-align: center;
                `;
                progressDiv.textContent = `${currentMission.progress}/${currentMission.maxProgress}`;
                missionDisplay.appendChild(progressDiv);
            }
            
            missionDisplay.appendChild(missionContainer);
        }
        
        function createColorIndicator(container, colorIndex, isCurrent = false, isCompleted = false) {
            const colorDiv = document.createElement('div');
            colorDiv.className = 'mission-color';
            
            if (isCompleted) {
                // ì™„ë£Œëœ ìƒ‰ìƒì€ ì²´í¬ë§ˆí¬ í‘œì‹œ
                colorDiv.style.cssText = `
                    background: linear-gradient(45deg, #4caf50, #81c784);
                    border: 3px solid var(--color-text);
                    display: flex; align-items: center; justify-content: center;
                    font-size: 1.2rem; color: white;
                `;
                colorDiv.textContent = 'âœ“';
            } else {
                colorDiv.style.backgroundColor = `#${currentThemeColors[colorIndex].toString(16).padStart(6, '0')}`;
                if (isCurrent) {
                    colorDiv.classList.add('current');
                } else {
                    colorDiv.style.opacity = '0.6';
                }
            }
            
            container.appendChild(colorDiv);
        }
        
        function updateCamera() {
            if (!player) return;
            cameraTarget.lerp(player.mesh.position, 0.08);

            const angle = -Math.PI / 18;
            const distance = 80;

            camera.position.x = cameraTarget.x + Math.sin(angle) * distance;
            camera.position.z = cameraTarget.z + Math.cos(angle) * distance;
            camera.position.y = cameraTarget.y + 60;
            
            camera.lookAt(cameraTarget);

            directionalLight.position.x = cameraTarget.x + 30;
            directionalLight.position.y = cameraTarget.y + 50;
            directionalLight.position.z = cameraTarget.z + 20;
            directionalLight.target.position.copy(cameraTarget);
            directionalLight.target.updateMatrixWorld();
        }

        function togglePause() {
            const pauseButton = document.getElementById('pause-button');
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED';
                pausePanel.style.display = 'flex';
                pauseButton.textContent = 'â–¶';
            } else if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                pausePanel.style.display = 'none';
                pauseButton.textContent = '||';
            }
            updateVirtualKeyboard();
        }

        function goHome() {
            gameState = 'MENU';
            pausePanel.style.display = 'none';
            hud.style.display = 'none';
            missionDisplay.style.display = 'none';
            mainMenu.style.display = 'flex';
            updateVirtualKeyboard();
        }

        // íŠœí† ë¦¬ì–¼ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
        function startTutorial() {
            console.log('íŠœí† ë¦¬ì–¼ ì‹œì‘');
            gameState = 'TUTORIAL';
            tutorialData.isActive = true;
            tutorialData.currentStep = 0;
            tutorialData.hasPlayerMoved = false;
            tutorialData.hasSteppedCorrectTile = false;
            
            // UI ì„¤ì •
            mainMenu.style.display = 'none';
            hud.style.display = 'flex';
            missionDisplay.style.display = 'flex';
            tutorialOverlay.style.display = 'block';
            
            // ê²Œì„ ì´ˆê¸°í™” (ì‹œê°„ ì •ì§€ ìƒíƒœ)
            initializeGame();
            gameData.time = GAME_CONFIG.INITIAL_TIME;
            
            // ì²« ë²ˆì§¸ ë‹¨ê³„ í‘œì‹œ
            updateTutorialUI();
            
            updateVirtualKeyboard();
        }
        
        function updateTutorialUI() {
            const step = tutorialSteps[tutorialData.currentStep];
            tutorialTitle.textContent = step.title;
            tutorialDescription.textContent = step.description;
            tutorialProgress.textContent = `${tutorialData.currentStep + 1}/${tutorialSteps.length}`;
            
            // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            tutorialPrevBtn.disabled = tutorialData.currentStep === 0;
            tutorialNextBtn.disabled = step.autoNext && !checkStepCompletion(step);
            
            if (step.isLastStep) {
                tutorialNextBtn.textContent = 'ì™„ë£Œ';
            } else {
                tutorialNextBtn.textContent = 'ë‹¤ìŒ';
            }
        }
        
        function checkStepCompletion(step) {
            if (step.waitForMove) {
                return tutorialData.hasPlayerMoved;
            }
            if (step.waitForCorrectTile) {
                return tutorialData.hasSteppedCorrectTile;
            }
            return true;
        }
        
        function nextTutorialStep() {
            const currentStep = tutorialSteps[tutorialData.currentStep];
            
            if (currentStep.isLastStep) {
                exitTutorial();
                return;
            }
            
            if (tutorialData.currentStep < tutorialSteps.length - 1) {
                tutorialData.currentStep++;
                
                // ë‹¨ê³„ë³„ ì´ˆê¸°í™”
                const nextStep = tutorialSteps[tutorialData.currentStep];
                if (nextStep.waitForMove) {
                    tutorialData.hasPlayerMoved = false;
                }
                if (nextStep.waitForCorrectTile) {
                    tutorialData.hasSteppedCorrectTile = false;
                }
                
                // ê°•ì œ ë¯¸ì…˜ ì„¤ì •
                if (nextStep.forcedMissionColor !== undefined) {
                    gameData.currentMission = [nextStep.forcedMissionColor];
                    updateMissionUI();
                }
                
                updateTutorialUI();
            }
        }
        
        function previousTutorialStep() {
            if (tutorialData.currentStep > 0) {
                tutorialData.currentStep--;
                updateTutorialUI();
            }
        }
        
        function exitTutorial() {
            console.log('íŠœí† ë¦¬ì–¼ ì¢…ë£Œ');
            tutorialData.isActive = false;
            tutorialOverlay.style.display = 'none';
            goHome();
        }
        
        function initializeGame() {
            // ê¸°ì¡´ íƒ€ì¼ ì •ë¦¬
            tiles.forEach(tile => {
                if (tile.reactivationTimeout) {
                    clearTimeout(tile.reactivationTimeout);
                }
                scene.remove(tile.mesh);
            });
            tiles.clear();
            
            // í”Œë ˆì´ì–´ ìƒì„±
            if (player) {
                scene.remove(player.mesh);
            }
            createPlayer();
            
            // ê¸°ë³¸ íƒ€ì¼ ìƒì„±
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    const colorIndex = Math.floor(Math.random() * currentThemeColors.length);
                    createTile(dx, dy, colorIndex);
                }
            }
            
            // ì²« ë¯¸ì…˜ ìƒì„±
            addNewMission();
            updateMissionUI();
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            if (gameState === 'PLAYING') {
                update(deltaTime);
                updateCamera();
            } else if (gameState === 'TUTORIAL') {
                // íŠœí† ë¦¬ì–¼ ìƒíƒœì—ì„œëŠ” ì‹œê°„ íë¦„ ì •ì§€, í”Œë ˆì´ì–´ ì´ë™ë§Œ ì²˜ë¦¬
                if (player) {
                    player.mesh.position.lerp(player.targetPosition, 0.2);
                    checkPlayerOnTile();
                    updateTiles();
                    updateCamera();
                }
            }
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
