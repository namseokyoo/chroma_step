<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>크로마 스텝 (Chroma Step) - MVP v2.6</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        :root {
            --color-bg: #121212; --color-text: #e0e0e0; --color-ui-bg: #1e1e1e;
            --color-cyan: #18ffff; --color-yellow: #ffc400;
        }

        body {
            margin: 0; padding: 0; font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--color-bg); color: var(--color-text);
            display: flex; justify-content: center; align-items: center;
            width: 100vw; height: 100vh; overflow: hidden;
        }

        #game-container {
            width: 100%; max-width: 1000px; height: 100%;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; position: relative;
        }

        #canvas-container {
            width: 100%; height: 80%; background-color: #000;
            border-radius: 16px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            position: relative;
        }

        canvas { display: block; width: 100%; height: 100%; border-radius: 16px; }
        
        .ui-panel {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(18, 18, 18, 0.95); display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 10; border-radius: 16px; text-align: center;
            padding: 20px; box-sizing: border-box; animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .ui-panel h1 { font-size: 3rem; margin-bottom: 10px; letter-spacing: 2px; text-shadow: 0 0 10px var(--color-cyan); }
        .ui-panel p { font-size: 1.2rem; margin-bottom: 30px; }

        .ui-button {
            padding: 15px 30px; font-size: 1.2rem; font-weight: 700;
            color: var(--color-bg); background-color: var(--color-cyan);
            border: none; border-radius: 50px; cursor: pointer;
            transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(24, 255, 255, 0.3);
            margin: 5px;
        }
        .ui-button:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(24, 255, 255, 0.5); }
        
        #game-over-panel .stats { margin: 20px 0; font-size: 1.5rem; }
        #game-over-panel .new-highscore { color: var(--color-yellow); animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #hud {
            width: 100%; padding: 20px; box-sizing: border-box; position: absolute;
            top: 0; left: 0; z-index: 5; display: flex; justify-content: space-between;
            align-items: flex-start;
        }
        .hud-group { background-color: rgba(30, 30, 30, 0.8); padding: 10px 20px; border-radius: 12px; backdrop-filter: blur(5px); }
        #score-display, #combo-display { font-size: 1.5rem; font-weight: 700; }
        #combo-display { color: #ffab40; }
        #time-bar-container { width: 100%; height: 10px; background-color: rgba(255,255,255,0.2); border-radius: 5px; margin-top: 5px; }
        #time-bar { width: 100%; height: 100%; background-color: #69f0ae; border-radius: 5px; transition: width 0.1s linear; }
        #mission-display {
            display: flex; gap: 8px; padding: 10px; background-color: rgba(30, 30, 30, 0.8);
            border-radius: 12px; backdrop-filter: blur(5px); position: absolute;
            top: 20px; left: 50%; transform: translateX(-50%); pointer-events: none;
        }
        .mission-color {
            width: 30px; height: 30px; border-radius: 50%; border: 3px solid var(--color-text);
            transition: all 0.3s ease;
        }
        .mission-color.current { transform: scale(1.2); box-shadow: 0 0 15px #fff; }
        .mission-success-anim { animation: missionSuccess 0.5s ease-in-out; }
        @keyframes missionSuccess {
            0% { transform: scale(1.2); box-shadow: 0 0 15px #fff; }
            50% { transform: scale(1.5); box-shadow: 0 0 25px var(--color-yellow); }
            100% { transform: scale(0); opacity: 0; }
        }

        #pause-button {
            background-color: rgba(30, 30, 30, 0.8); backdrop-filter: blur(5px);
            border: 2px solid var(--color-text); color: var(--color-text);
            width: 50px; height: 50px; font-size: 1.5rem;
            border-radius: 50%; cursor: pointer;
            margin-left: 15px;
        }

        #settings-panel .theme-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 15px; width: 100%; max-width: 400px;
        }
        .theme-option { display: flex; align-items: center; width: 100%; }
        .theme-button {
            flex-grow: 1; text-align: left; border: 2px solid var(--color-text);
            background-color: transparent; color: var(--color-text);
        }
        .theme-button.selected {
            border-color: var(--color-cyan); background-color: rgba(24, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(24, 255, 255, 0.5);
        }
        .theme-preview { display: flex; margin-left: 15px; }
        .theme-swatch {
            width: 20px; height: 20px; border-radius: 50%;
            margin-left: -5px; border: 2px solid var(--color-bg);
        }

        /* 모바일 가상 키보드 스타일 */
        #virtual-keyboard {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 1000; pointer-events: none; display: none;
        }
        #virtual-keyboard.show {
            display: block;
        }
        .keyboard-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 10px; pointer-events: auto;
        }
        .keyboard-row {
            display: flex; gap: 15px; align-items: center;
        }
        .keyboard-key {
            width: 60px; height: 60px; border-radius: 50%;
            background-color: rgba(30, 30, 30, 0.9); color: var(--color-text);
            border: 2px solid var(--color-cyan); font-size: 20px; font-weight: bold;
            cursor: pointer; transition: all 0.2s ease;
            backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .keyboard-key:hover, .keyboard-key:active {
            background-color: var(--color-cyan); color: var(--color-bg);
            transform: scale(1.1); box-shadow: 0 6px 20px rgba(24, 255, 255, 0.4);
        }
        .keyboard-key:active {
            transform: scale(0.95);
        }
        

        /* 설정 패널 스타일 */
        .settings-section {
            margin-bottom: 30px; width: 100%; max-width: 400px;
        }
        .setting-item {
            display: flex; align-items: center; margin-bottom: 10px;
        }
        .setting-label {
            display: flex; align-items: center; cursor: pointer;
            font-size: 1.1rem; gap: 10px;
        }
        .setting-label input[type="checkbox"] {
            width: 20px; height: 20px; cursor: pointer;
        }

        /* 모바일 HUD 최적화 */
        @media (max-width: 768px) {
            #hud {
                padding: 5px;
            }
            .hud-group {
                padding: 5px 8px;
            }
            #score-display, #combo-display {
                font-size: 0.9rem;
            }
            #time-display {
                font-size: 0.9rem;
            }
            #mission-display {
                top: 5px;
                gap: 4px;
                padding: 5px;
            }
            .mission-color {
                width: 20px;
                height: 20px;
            }
            #pause-button {
                width: 35px;
                height: 35px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="canvas-container">
            <canvas id="game-canvas"></canvas>
            <div id="hud" style="display: none;">
                <div class="hud-group">
                    <div id="score-display">Score: 0</div>
                    <div id="combo-display">Combo: x1.0</div>
                </div>
                <div class="hud-group" style="display: flex; align-items: center;">
                    <div>
                        <div id="time-display">Time: 60.0</div>
                        <div id="time-bar-container"><div id="time-bar"></div></div>
                    </div>
                    <button id="pause-button">||</button>
                </div>
                <div id="invincibility-timer" style="display: none; position: absolute; top: 80px; right: 20px; background: rgba(255, 255, 0, 0.9); color: black; padding: 8px 16px; border-radius: 8px; font-size: 1.2rem; font-weight: bold; z-index: 1000;">
                    무적: <span id="invincibility-countdown">5</span>초
                </div>
            </div>
            <div id="mission-display" style="display: none;"></div>
            <div id="main-menu" class="ui-panel">
                <h1 style="font-size: 3.5rem; margin-bottom: 30px;">CHROMA STEP</h1>
                <p style="font-size: 1rem; margin-bottom: 30px;">High Score: <span id="high-score">0</span></p>
                <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                    <button id="start-button" class="ui-button">게임 시작</button>
                    <button id="tutorial-button" class="ui-button">튜토리얼</button>
                    <button id="settings-button" class="ui-button">설정</button>
                </div>
            </div>
            <div id="game-over-panel" class="ui-panel" style="display: none;">
                <h1>GAME OVER</h1>
                <div class="stats">
                    <p>Final Score: <span id="final-score">0</span></p>
                    <p class="new-highscore" style="display: none;">NEW HIGH SCORE!</p>
                    <p>Color Sparks: +<span id="sparks-earned">0</span></p>
                </div>
                <button id="restart-button" class="ui-button">다시 시작</button>
            </div>
            <div id="settings-panel" class="ui-panel" style="display: none;">
                <h1>설정</h1>
                <div class="settings-section">
                    <h2 style="font-size: 1.5rem; margin-bottom: 15px;">색상 테마</h2>
                    <div id="theme-container" class="theme-container"></div>
                </div>
                <div class="settings-section">
                    <h2 style="font-size: 1.5rem; margin-bottom: 15px;">모바일 설정</h2>
                    <div class="setting-item">
                        <label class="setting-label">
                            <input type="checkbox" id="virtual-keyboard-toggle" />
                            <span>가상 키보드 표시</span>
                        </label>
                    </div>
                </div>
                <button id="back-to-menu-button" class="ui-button">뒤로 가기</button>
            </div>
            <div id="pause-panel" class="ui-panel" style="display: none;">
                <h1>일시정지</h1>
                <button id="resume-button" class="ui-button">계속하기</button>
                <button id="home-button" class="ui-button">홈으로</button>
            </div>
            
            <!-- 튜토리얼 오버레이 -->
            <div id="tutorial-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 2000;">
                <div id="tutorial-content" style="position: absolute; bottom: 20px; right: 20px; max-width: 400px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);">
                    <div id="tutorial-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 id="tutorial-title" style="margin: 0; font-size: 1.2rem; color: #333;">튜토리얼</h3>
                        <span id="tutorial-progress" style="font-size: 0.9rem; color: #666;">1/7</span>
                    </div>
                    <div id="tutorial-description" style="margin-bottom: 20px; font-size: 1rem; color: #333; line-height: 1.4;">
                        게임을 시작하겠습니다!
                    </div>
                    <div id="tutorial-controls" style="display: flex; justify-content: space-between; gap: 10px;">
                        <button id="tutorial-skip" class="ui-button" style="background: #666; font-size: 0.9rem; padding: 8px 16px;">건너뛰기</button>
                        <div style="display: flex; gap: 10px;">
                            <button id="tutorial-prev" class="ui-button" style="font-size: 0.9rem; padding: 8px 16px;" disabled>이전</button>
                            <button id="tutorial-next" class="ui-button" style="font-size: 0.9rem; padding: 8px 16px;">다음</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 모바일 가상 키보드 -->
        <div id="virtual-keyboard" style="display: none;">
            <div class="keyboard-container">
                <div class="keyboard-row">
                    <button id="key-up" class="keyboard-key">↑</button>
                </div>
                <div class="keyboard-row">
                    <button id="key-left" class="keyboard-key">←</button>
                    <button id="key-down" class="keyboard-key">↓</button>
                    <button id="key-right" class="keyboard-key">→</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- 크로마 스텝 MVP 스크립트 ---
        // 기획서 버전 1.2 기반 / 수정사항 v2.6 (Color Fix)
        
        const scene = new THREE.Scene();
        const canvas = document.querySelector('#game-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        const camera = new THREE.OrthographicCamera(
            canvas.clientWidth / -2, canvas.clientWidth / 2,
            canvas.clientHeight / 2, canvas.clientHeight / -2,
            1, 1000
        );
        const cameraTarget = new THREE.Vector3(0, 0, 0);
        camera.position.set(0, 60, 60); 
        camera.lookAt(cameraTarget);

        // *** 수정: 색상 테마 개편 ***
        const COLOR_THEMES = {
            '선명한 무지개': [0xf44336, 0xff9800, 0xffeb3b, 0x4caf50, 0x2196f3, 0x3f51b5, 0x9c27b0],
            '네온의 꿈': [0xf06292, 0x4fc3f7, 0xffee58, 0x81c784, 0xba68c8, 0xff8a65, 0x4dd0e1],
            '사이버펑크 네온': [0xff00ff, 0x00ffff, 0x00ff00, 0xffff00, 0xff00aa, 0x00aaff, 0xaa00ff],
            '파스텔 정원': [0xef9a9a, 0xa5d6a7, 0xffcc80, 0x90caf9, 0xce93d8, 0xf48fb1, 0x80cbc4]
        };
        const DEACTIVATED_COLOR = 0x424242;
        let currentThemeColors = [];

        // 이벤트 블록 시스템
        const EVENT_BLOCK_TYPES = {
            TIME_GAIN: 'time_gain',
            TIME_LOSS: 'time_loss',
            INVINCIBILITY: 'invincibility'
        };

        const EVENT_BLOCK_CONFIG = {
            SPAWN_PROBABILITY: 0.02, // 2% 확률
            TIME_GAIN_AMOUNT: 5,
            TIME_LOSS_AMOUNT: 5,
            INVINCIBILITY_DURATION: 5,
            COLORS: {
                TIME_GAIN: 0x00ff00,    // 초록색
                TIME_LOSS: 0xff0000,    // 빨간색
                INVINCIBILITY: 0xffff00  // 노란색
            }
        };

        const GAME_CONFIG = {
            INITIAL_TIME: 60, BASE_SCORE_PER_TILE: 100,
            COMBO_MULTIPLIER: 0.1, MAX_COMBO_BONUS: 3.0,
            TIME_REWARD_BASE: 2,
            TILE_SIZE: 5, TILE_GAP: 1, GRID_RADIUS: 15, 
            TILE_RESPAWN_TIME: 5000,
            TIME_PENALTY_PER_MOVE: 0.5,
        };
        
        let gameState = 'MENU';
        let gameData = {
            score: 0, time: GAME_CONFIG.INITIAL_TIME, combo: 1,
            currentMission: [],
            highScore: 0, colorSparks: 0,
            isInvincible: false,
            invincibilityEndTime: 0
        };
        let gameSettings = {
            theme: '선명한 무지개',
            showVirtualKeyboard: true
        };
        
        // 튜토리얼 시스템
        const tutorialSteps = [
            {
                id: 0,
                title: "게임 소개",
                description: "CHROMA STEP에 오신 걸 환영합니다! 색깔 블록을 밟아 미션을 완료하는 리듬 게임입니다.",
                highlight: null,
                playerCanMove: false,
                autoNext: false
            },
            {
                id: 1,
                title: "이동 방법",
                description: "방향키 또는 WASD로 이동할 수 있습니다. 한 번 이동해보세요!",
                highlight: "player",
                playerCanMove: true,
                autoNext: true,
                waitForMove: true
            },
            {
                id: 2,
                title: "미션 시스템",
                description: "화면 상단에 표시된 색깔이 현재 미션입니다. 이 색깔과 일치하는 블록을 찾아 밟으세요!",
                highlight: "mission",
                playerCanMove: true,
                autoNext: false,
                forcedMissionColor: 0
            },
            {
                id: 3,
                title: "올바른 블록 밟기",
                description: "미션 색깔과 일치하는 블록을 밟으면 점수를 얻습니다. 한 번 밟아보세요!",
                highlight: "tile",
                playerCanMove: true,
                autoNext: true,
                waitForCorrectTile: true
            },
            {
                id: 4,
                title: "콤보 시스템",
                description: "연속으로 성공하면 콤보가 증가하여 더 많은 점수를 얻을 수 있습니다!",
                highlight: "combo",
                playerCanMove: true,
                autoNext: false
            },
            {
                id: 5,
                title: "특수 블록",
                description: "가끔 특수 블록이 나타납니다. 초록색(+T)은 시간 증가, 빨간색(-T)은 시간 감소, 노란색(★)은 무적 상태입니다.",
                highlight: null,
                playerCanMove: true,
                autoNext: false
            },
            {
                id: 6,
                title: "시간 관리",
                description: "시간이 다 떨어지면 게임 오버! 올바른 블록을 밟으면 시간이 회복됩니다. 이제 실제 게임을 시작해보세요!",
                highlight: "time",
                playerCanMove: true,
                autoNext: false,
                isLastStep: true
            }
        ];
        
        let tutorialData = {
            isActive: false,
            currentStep: 0,
            hasPlayerMoved: false,
            hasSteppedCorrectTile: false
        };
        
        let player, clock = new THREE.Clock(), tiles = new Map(), directionalLight;
        let frameCounter = 0; // 성능 최적화용 프레임 카운터
        
        // 이벤트 블록 생성 확률 체크
        function shouldCreateEventBlock() {
            if (Math.random() < EVENT_BLOCK_CONFIG.SPAWN_PROBABILITY) {
                const types = Object.values(EVENT_BLOCK_TYPES);
                return types[Math.floor(Math.random() * types.length)];
            }
            return null;
        }
        
        // 이벤트 블록에 심볼 추가
        function addEventBlockSymbol(tileMesh, eventBlockType) {
            const symbolGeometry = new THREE.PlaneGeometry(4, 4); // 크기 증가
            let symbolText = '';
            
            switch(eventBlockType) {
                case EVENT_BLOCK_TYPES.TIME_GAIN:
                    symbolText = '+T';
                    break;
                case EVENT_BLOCK_TYPES.TIME_LOSS:
                    symbolText = '-T';
                    break;
                case EVENT_BLOCK_TYPES.INVINCIBILITY:
                    symbolText = '★';
                    break;
            }
            
            // 텍스트 텍스처 생성
            const canvas = document.createElement('canvas');
            canvas.width = 256; // 해상도 증가
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // 검은색 배경 추가 (대비 향상)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 256, 256);
            
            // 흰색 테두리 추가
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 8;
            ctx.font = 'bold 120px Arial'; // 폰트 크기 증가
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeText(symbolText, 128, 128);
            
            // 흰색 텍스트
            ctx.fillStyle = 'white';
            ctx.fillText(symbolText, 128, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            const symbolMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                alphaTest: 0.1
            });
            
            const symbolMesh = new THREE.Mesh(symbolGeometry, symbolMaterial);
            symbolMesh.position.set(0, 0.6, 0);
            symbolMesh.rotation.x = -Math.PI / 2;
            tileMesh.add(symbolMesh);
        }
        
        // 이벤트 블록 효과 처리
        function handleEventBlock(eventBlockType) {
            console.log('이벤트 블록 효과 발동:', eventBlockType); // 디버깅용
            
            switch(eventBlockType) {
                case EVENT_BLOCK_TYPES.TIME_GAIN:
                    gameData.time += EVENT_BLOCK_CONFIG.TIME_GAIN_AMOUNT;
                    console.log('시간 +5초 획득! 현재 시간:', gameData.time);
                    createParticleEffect('time_gain');
                    break;
                case EVENT_BLOCK_TYPES.TIME_LOSS:
                    gameData.time -= EVENT_BLOCK_CONFIG.TIME_LOSS_AMOUNT;
                    if (gameData.time < 0) gameData.time = 0;
                    console.log('시간 -5초 손실! 현재 시간:', gameData.time);
                    createParticleEffect('time_loss');
                    break;
                case EVENT_BLOCK_TYPES.INVINCIBILITY:
                    gameData.isInvincible = true;
                    gameData.invincibilityEndTime = Date.now() + (EVENT_BLOCK_CONFIG.INVINCIBILITY_DURATION * 1000);
                    console.log('무적 상태 활성화! 5초간 지속');
                    createParticleEffect('invincibility');
                    activateInvincibilityEffect();
                    break;
            }
        }
        
        // 무적 효과 시각화
        function activateInvincibilityEffect() {
            if (player && player.mesh) {
                player.mesh.material.emissive.setHex(0xffff00);
                player.mesh.material.emissiveIntensity = 0.8;
                console.log('무적 효과 활성화됨'); // 디버깅용
                
                // 무적 타이머 UI 표시
                invincibilityTimer.style.display = 'block';
                updateInvincibilityTimer();
            }
        }
        
        // 무적 효과 해제
        function deactivateInvincibilityEffect() {
            if (player && player.mesh) {
                player.mesh.material.emissive.setHex(0x000000);
                player.mesh.material.emissiveIntensity = 0;
                console.log('무적 효과 해제됨'); // 디버깅용
                
                // 무적 타이머 UI 숨기기
                invincibilityTimer.style.display = 'none';
            }
        }
        
        // 무적 타이머 업데이트
        function updateInvincibilityTimer() {
            if (gameData.isInvincible) {
                const remaining = Math.max(0, (gameData.invincibilityEndTime - Date.now()) / 1000);
                invincibilityCountdown.textContent = Math.ceil(remaining);
                
                if (remaining > 0) {
                    setTimeout(updateInvincibilityTimer, 100);
                }
            }
        }
        
        // 파티클 효과 생성
        function createParticleEffect(type) {
            if (!player) return; // 플레이어가 없으면 파티클 생성 안함
            
            const particleGroup = new THREE.Group();
            const particleCount = 30; // 파티클 개수 증가
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8); // 크기 증가
                let particleMaterial;
                
                switch(type) {
                    case 'time_gain':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x00ff00, 
                            transparent: true,
                            emissive: 0x00ff00,
                            emissiveIntensity: 0.5
                        });
                        break;
                    case 'time_loss':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xff0000, 
                            transparent: true,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.5
                        });
                        break;
                    case 'invincibility':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xffff00, 
                            transparent: true,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.5
                        });
                        break;
                }
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(player.mesh.position); // player.mesh.position 사용
                particle.position.y += 2; // 플레이어 위쪽에서 시작
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    Math.random() * 8 + 2,
                    (Math.random() - 0.5) * 15
                );
                particle.life = 2.0; // 수명 증가
                particleGroup.add(particle);
            }
            
            scene.add(particleGroup);
            
            // 파티클 애니메이션
            const animateParticles = () => {
                particleGroup.children.forEach(particle => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(0.03));
                    particle.velocity.y -= 0.3; // 중력 증가
                    particle.life -= 0.03;
                    particle.material.opacity = particle.life / 2.0;
                    
                    if (particle.life <= 0) {
                        particleGroup.remove(particle);
                    }
                });
                
                if (particleGroup.children.length > 0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particleGroup);
                }
            };
            
            animateParticles();
        }

        const hud = document.getElementById('hud');
        const mainMenu = document.getElementById('main-menu');
        const gameOverPanel = document.getElementById('game-over-panel');
        const settingsPanel = document.getElementById('settings-panel');
        const pausePanel = document.getElementById('pause-panel');
        const scoreDisplay = document.getElementById('score-display');
        const comboDisplay = document.getElementById('combo-display');
        const timeDisplay = document.getElementById('time-display');
        const timeBar = document.getElementById('time-bar');
        const missionDisplay = document.getElementById('mission-display');
        const highScoreDisplay = document.getElementById('high-score');
        const finalScoreDisplay = document.getElementById('final-score');
        const sparksEarnedDisplay = document.getElementById('sparks-earned');
        const newHighScoreBadge = gameOverPanel.querySelector('.new-highscore');
        const virtualKeyboard = document.getElementById('virtual-keyboard');
        const keyboardToggle = document.getElementById('virtual-keyboard-toggle');
        const invincibilityTimer = document.getElementById('invincibility-timer');
        const invincibilityCountdown = document.getElementById('invincibility-countdown');
        const tutorialOverlay = document.getElementById('tutorial-overlay');
        const tutorialTitle = document.getElementById('tutorial-title');
        const tutorialDescription = document.getElementById('tutorial-description');
        const tutorialProgress = document.getElementById('tutorial-progress');
        const tutorialPrevBtn = document.getElementById('tutorial-prev');
        const tutorialNextBtn = document.getElementById('tutorial-next');
        const tutorialSkipBtn = document.getElementById('tutorial-skip');

        function init() {
            scene.background = new THREE.Color(0x121212);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(30, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            const groundGeometry = new THREE.PlaneGeometry(5000, 5000);
            const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.51;
            ground.receiveShadow = true;
            scene.add(ground);

            loadGameData();
            setupSettingsPanel();
            setupVirtualKeyboard();
            applyTheme();

            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('tutorial-button').addEventListener('click', startTutorial);
            document.getElementById('settings-button').addEventListener('click', showSettingsPanel);
            document.getElementById('back-to-menu-button').addEventListener('click', showMainMenu);
            document.getElementById('restart-button').addEventListener('click', startGame);
            document.getElementById('pause-button').addEventListener('click', togglePause);
            document.getElementById('resume-button').addEventListener('click', togglePause);
            document.getElementById('home-button').addEventListener('click', goHome);
            
            // 튜토리얼 버튼 이벤트
            tutorialPrevBtn.addEventListener('click', previousTutorialStep);
            tutorialNextBtn.addEventListener('click', nextTutorialStep);
            tutorialSkipBtn.addEventListener('click', exitTutorial);
            
            window.addEventListener('keydown', handleInput);
            window.addEventListener('resize', () => {
                onWindowResize();
                updateVirtualKeyboard();
            });

            onWindowResize();
            updateVirtualKeyboard(); // 초기화 시 가상 키보드 상태 업데이트
            animate();
        }

        function isMobileDevice() {
            const widthCheck = window.innerWidth <= 768;
            const userAgentCheck = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const result = widthCheck || userAgentCheck;
            
            console.log('모바일 감지:', {
                windowWidth: window.innerWidth,
                widthCheck: widthCheck,
                userAgent: navigator.userAgent,
                userAgentCheck: userAgentCheck,
                finalResult: result
            });
            
            return result;
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            renderer.setSize(width, height);
            
            // 모바일 최적화: 화면 크기에 따라 줌 레벨 조정
            const zoom = isMobileDevice() ? 0.035 : 0.025; // 모바일에서는 더 넓게
            
            camera.left = -width * zoom; camera.right = width * zoom;
            camera.top = height * zoom; camera.bottom = -height * zoom;
            camera.updateProjectionMatrix();
        }

        function loadGameData() {
            const savedData = localStorage.getItem('chromaStepData');
            console.log('설정 로드:', savedData);
            
            if (savedData) {
                const parsed = JSON.parse(savedData);
                gameData.highScore = parsed.highScore || 0;
                gameData.colorSparks = parsed.colorSparks || 0;
                gameSettings.theme = parsed.theme || '선명한 무지개';
                gameSettings.showVirtualKeyboard = parsed.showVirtualKeyboard !== undefined ? parsed.showVirtualKeyboard : true;
            } else {
                console.log('저장된 설정이 없음, 기본값 사용');
                gameSettings.showVirtualKeyboard = true;
            }
            
            // 임시: 가상 키보드 강제 활성화 (테스트용)
            console.log('원래 설정:', gameSettings.showVirtualKeyboard);
            gameSettings.showVirtualKeyboard = true;
            console.log('강제 설정 후:', gameSettings.showVirtualKeyboard);
            
            console.log('최종 설정:', gameSettings);
        }

        function saveGameData() {
            localStorage.setItem('chromaStepData', JSON.stringify({
                highScore: gameData.highScore,
                colorSparks: gameData.colorSparks,
                theme: gameSettings.theme,
                showVirtualKeyboard: gameSettings.showVirtualKeyboard
            }));
        }

        function showSettingsPanel() {
            mainMenu.style.display = 'none';
            settingsPanel.style.display = 'flex';
        }
        function showMainMenu() {
            settingsPanel.style.display = 'none';
            mainMenu.style.display = 'flex';
        }
        function setupSettingsPanel() {
            const container = document.getElementById('theme-container');
            container.innerHTML = '';
            Object.keys(COLOR_THEMES).forEach(themeName => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'theme-option';

                const button = document.createElement('button');
                button.className = 'ui-button theme-button';
                button.textContent = themeName;
                if (themeName === gameSettings.theme) {
                    button.classList.add('selected');
                }
                button.addEventListener('click', () => {
                    gameSettings.theme = themeName;
                    applyTheme();
                    saveGameData();
                    container.querySelectorAll('.theme-button').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                });

                const previewDiv = document.createElement('div');
                previewDiv.className = 'theme-preview';
                COLOR_THEMES[themeName].forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'theme-swatch';
                    swatch.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}`;
                    previewDiv.appendChild(swatch);
                });
                
                optionDiv.appendChild(button);
                optionDiv.appendChild(previewDiv);
                container.appendChild(optionDiv);
            });
            
            // 가상 키보드 체크박스 상태 설정
            console.log('체크박스 설정:', gameSettings.showVirtualKeyboard);
            keyboardToggle.checked = gameSettings.showVirtualKeyboard;
        }
        function applyTheme() {
            currentThemeColors = COLOR_THEMES[gameSettings.theme];
        }

        function clearAllTimeouts() {
            // 모든 타일의 타임아웃을 정리
            for (const tile of tiles.values()) {
                if (tile.reactivationTimeout) {
                    clearTimeout(tile.reactivationTimeout);
                    tile.reactivationTimeout = null;
                }
            }
        }

        function updateVirtualKeyboard() {
            const isMobile = isMobileDevice();
            const showKeyboard = gameSettings.showVirtualKeyboard;
            const isPlaying = gameState === 'PLAYING';
            
            console.log('=== 가상 키보드 디버깅 ===');
            console.log('isMobile:', isMobile);
            console.log('showKeyboard:', showKeyboard);
            console.log('isPlaying:', isPlaying);
            console.log('virtualKeyboard element:', virtualKeyboard);
            
            // CSS 우선순위 문제 해결: 인라인 스타일 제거
            virtualKeyboard.style.display = '';
            
            if (isMobile && showKeyboard && isPlaying) {
                virtualKeyboard.classList.add('show');
                console.log('✅ 키보드 표시 조건 만족 - 표시함');
            } else {
                virtualKeyboard.classList.remove('show');
                console.log('❌ 키보드 표시 조건 불만족 - 숨김');
                console.log('조건 체크: isMobile &&', isMobile, '&& showKeyboard &&', showKeyboard, '&& isPlaying &&', isPlaying);
            }
            
            console.log('최종 classList:', virtualKeyboard.classList);
        }

        function setupVirtualKeyboard() {
            // 가상 키보드 버튼 이벤트 설정
            const keyUp = document.getElementById('key-up');
            const keyDown = document.getElementById('key-down');
            const keyLeft = document.getElementById('key-left');
            const keyRight = document.getElementById('key-right');
            
            if (keyUp) keyUp.addEventListener('click', () => handleVirtualKey('ArrowUp'));
            if (keyDown) keyDown.addEventListener('click', () => handleVirtualKey('ArrowDown'));
            if (keyLeft) keyLeft.addEventListener('click', () => handleVirtualKey('ArrowLeft'));
            if (keyRight) keyRight.addEventListener('click', () => handleVirtualKey('ArrowRight'));
            
            // 체크박스 이벤트 설정
            if (keyboardToggle) {
                keyboardToggle.addEventListener('change', (e) => {
                    console.log('체크박스 변경:', e.target.checked);
                    gameSettings.showVirtualKeyboard = e.target.checked;
                    updateVirtualKeyboard();
                    saveGameData();
                });
            } else {
                console.log('⚠️ 체크박스 엘리먼트가 없습니다!');
            }
        }

        function handleVirtualKey(key) {
            if (gameState !== 'PLAYING') return;
            
            // 버튼 누름 효과
            const button = document.getElementById(`key-${key.replace('Arrow', '').toLowerCase()}`);
            if (button) {
                button.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    button.style.transform = '';
                }, 100);
            }
            
            // 키 입력 시뮬레이션
            handleInput({ key: key });
        }

        function startGame() {
            mainMenu.style.display = 'none';
            gameOverPanel.style.display = 'none';
            pausePanel.style.display = 'none';
            hud.style.display = 'flex';
            missionDisplay.style.display = 'flex';
            document.getElementById('pause-button').textContent = '||';

            gameData.score = 0;
            gameData.time = GAME_CONFIG.INITIAL_TIME;
            gameData.combo = 1;
            gameData.currentMission = [];
            
            // 메모리 누수 방지: 모든 타임아웃 정리
            clearAllTimeouts();
            
            tiles.forEach(tile => scene.remove(tile.mesh));
            tiles.clear();
            if (player) scene.remove(player.mesh);

            createPlayer();
            camera.position.set(0, 60, 60);
            cameraTarget.set(0, 0, 0);
            updateCamera();

            for (let i = 0; i < 3; i++) {
                addNewMission();
            }
            updateWorld(); // 이미 ensureMissionTileExists를 호출함
            
            const startTile = tiles.get('0,0');
            if (startTile && startTile.colorIndex === gameData.currentMission[0]) {
                let newColorIndex;
                do {
                    newColorIndex = Math.floor(Math.random() * currentThemeColors.length);
                } while (newColorIndex === gameData.currentMission[0]);
                startTile.colorIndex = newColorIndex;
                startTile.mesh.material.color.set(currentThemeColors[newColorIndex]);
            }

            gameState = 'PLAYING';
            updateVirtualKeyboard();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            
            // 메모리 누수 방지: 모든 타임아웃 정리
            clearAllTimeouts();
            
            hud.style.display = 'none';
            missionDisplay.style.display = 'none';
            gameOverPanel.style.display = 'flex';

            finalScoreDisplay.textContent = gameData.score.toLocaleString();
            if (gameData.score > gameData.highScore) {
                gameData.highScore = gameData.score;
                newHighScoreBadge.style.display = 'block';
            } else {
                newHighScoreBadge.style.display = 'none';
            }
            
            const sparks = Math.floor(gameData.score / 100);
            sparksEarnedDisplay.textContent = sparks.toLocaleString();
            gameData.colorSparks += sparks;
            
            saveGameData();
            highScoreDisplay.textContent = gameData.highScore.toLocaleString();
            updateVirtualKeyboard();
        }

        function update(deltaTime) {
            if (gameState !== 'PLAYING' || !player) return;

            gameData.time -= deltaTime;
            if (gameData.time <= 0) {
                gameData.time = 0;
                gameOver();
            }
            
            // 무적 상태 확인
            if (gameData.isInvincible && Date.now() > gameData.invincibilityEndTime) {
                gameData.isInvincible = false;
                deactivateInvincibilityEffect();
            }
            
            player.mesh.position.lerp(player.targetPosition, 0.2);
            checkPlayerOnTile();
            updateWorld();
            updateUI();
            updateTiles();
        }

        function updateUI() {
            scoreDisplay.textContent = `Score: ${gameData.score.toLocaleString()}`;
            const comboBonus = 1.0 + (gameData.combo - 1) * GAME_CONFIG.COMBO_MULTIPLIER;
            comboDisplay.textContent = `Combo: x${Math.min(comboBonus, GAME_CONFIG.MAX_COMBO_BONUS).toFixed(1)}`;
            timeDisplay.textContent = `Time: ${gameData.time.toFixed(1)}`;
            timeBar.style.width = `${(gameData.time / GAME_CONFIG.INITIAL_TIME) * 100}%`;
        }
        
        function createPlayer() {
            const geometry = new THREE.SphereGeometry(GAME_CONFIG.TILE_SIZE * 0.4, 32, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, emissive: 0xcccccc, metalness: 0.1, roughness: 0.2
            });
            const playerY = 0.5 + (GAME_CONFIG.TILE_SIZE * 0.4);
            player = {
                mesh: new THREE.Mesh(geometry, material),
                gridX: 0, gridY: 0,
                targetPosition: new THREE.Vector3(0, playerY, 0)
            };
            player.mesh.castShadow = true;
            player.mesh.position.copy(player.targetPosition);
            scene.add(player.mesh);
        }

        function handleInput(event) {
            if (gameState !== 'PLAYING' && gameState !== 'TUTORIAL') return;
            
            // 튜토리얼 상태에서는 플레이어 이동 허용 여부 확인
            if (gameState === 'TUTORIAL') {
                const currentStep = tutorialSteps[tutorialData.currentStep];
                if (!currentStep.playerCanMove) return;
            }
            
            let dx = 0, dy = 0;
            switch (event.key) {
                case 'ArrowUp':    dy = 1; break;
                case 'ArrowDown':  dy = -1; break;
                case 'ArrowLeft':  dx = -1; break;
                case 'ArrowRight': dx = 1; break;
                default: return;
            }
            
            const nextGridX = player.gridX + dx;
            const nextGridY = player.gridY + dy;
            const nextTileKey = `${nextGridX},${nextGridY}`;
            const nextTile = tiles.get(nextTileKey);

            // 무적 상태일 때는 비활성화된 블록 위로도 이동 가능
            if (nextTile && (!nextTile.isDeactivated || gameData.isInvincible)) {
                player.gridX = nextGridX;
                player.gridY = nextGridY;
                const tileSpacing = GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_GAP;
                player.targetPosition.x = player.gridX * tileSpacing;
                player.targetPosition.z = player.gridY * tileSpacing * -1;
                
                // 튜토리얼 상태에서 이동 완료 표시
                if (gameState === 'TUTORIAL') {
                    tutorialData.hasPlayerMoved = true;
                    const currentStep = tutorialSteps[tutorialData.currentStep];
                    if (currentStep.autoNext && currentStep.waitForMove) {
                        updateTutorialUI();
                    }
                }
            }
        }
        
        function checkPlayerOnTile() {
            const tileKey = `${player.gridX},${player.gridY}`;
            const currentTile = tiles.get(tileKey);
            
            if (currentTile && !currentTile.isDeactivated) {
                handleStepOnTile(currentTile);
            }
            // 무적 상태에서 비활성화된 블록 위에 있을 때는 아무 효과 없음
        }

        function handleStepOnTile(tile) {
            tile.isDeactivated = true; 
            
            // 이벤트 블록 처리
            if (tile.eventBlockType) {
                handleEventBlock(tile.eventBlockType);
                deactivateAndScheduleReactivation(tile);
                return;
            }
            
            const expectedColorIndex = gameData.currentMission[0];

            if (tile.colorIndex === expectedColorIndex) {
                const missionIcon = missionDisplay.firstChild;
                if (missionIcon) {
                    missionIcon.classList.add('mission-success-anim');
                    // 애니메이션 완료 후 아이콘 제거
                    setTimeout(() => {
                        if (missionIcon.parentNode) {
                            missionIcon.remove();
                        }
                    }, 500);
                }

                gameData.score += Math.round(GAME_CONFIG.BASE_SCORE_PER_TILE * (1.0 + (gameData.combo - 1) * GAME_CONFIG.COMBO_MULTIPLIER));
                gameData.combo++;
                
                // 튜토리얼 상태가 아닐 때만 시간 업데이트
                if (gameState !== 'TUTORIAL') {
                    gameData.time += GAME_CONFIG.TIME_REWARD_BASE;
                }
                
                // 튜토리얼 상태에서 올바른 타일 밟기 완료 표시
                if (gameState === 'TUTORIAL') {
                    tutorialData.hasSteppedCorrectTile = true;
                    const currentStep = tutorialSteps[tutorialData.currentStep];
                    if (currentStep.autoNext && currentStep.waitForCorrectTile) {
                        updateTutorialUI();
                    }
                }
                
                // 레이스 컨디션 수정: 즉시 미션 업데이트
                gameData.currentMission.shift();
                addNewMission();
                ensureMissionTileExists();
                updateMissionUI();
            } else {
                gameData.combo = 1;
                // 튜토리얼 상태가 아닐 때만 시간 페널티
                if (gameState !== 'TUTORIAL') {
                    gameData.time -= GAME_CONFIG.TIME_PENALTY_PER_MOVE;
                }
                updateMissionUI();
            }
            
            deactivateAndScheduleReactivation(tile);
        }

        function addNewMission() {
            const newColorIndex = Math.floor(Math.random() * currentThemeColors.length);
            gameData.currentMission.push(newColorIndex);
        }

        function ensureMissionTileExists() {
            const nextMissionIndex = gameData.currentMission[0];
            if (nextMissionIndex === undefined) return;

            let missionTileExists = false;
            for (const tile of tiles.values()) {
                if (tile.colorIndex === nextMissionIndex && !tile.isDeactivated) {
                    missionTileExists = true;
                    break;
                }
            }

            if (!missionTileExists) {
                // 접근 가능한 타일을 우선적으로 선택 (플레이어 주변 타일)
                const accessibleTiles = [];
                const nearbyTiles = [];
                
                for (const tile of tiles.values()) {
                    if (tile.colorIndex !== nextMissionIndex && !tile.isDeactivated) {
                        const distance = Math.sqrt((tile.gridX - player.gridX)**2 + (tile.gridY - player.gridY)**2);
                        
                        // 플레이어와 인접한 타일 (거리 1-2)
                        if (distance <= 2 && distance > 0) {
                            accessibleTiles.push(tile);
                        } 
                        // 그 외 근처 타일 (거리 3-5)
                        else if (distance <= 5 && distance > 2) {
                            nearbyTiles.push(tile);
                        }
                    }
                }

                let targetTile = null;
                
                // 1순위: 접근 가능한 타일
                if (accessibleTiles.length > 0) {
                    targetTile = accessibleTiles[Math.floor(Math.random() * accessibleTiles.length)];
                } 
                // 2순위: 근처 타일
                else if (nearbyTiles.length > 0) {
                    targetTile = nearbyTiles[Math.floor(Math.random() * nearbyTiles.length)];
                } 
                // 3순위: 아무 타일
                else {
                    const allTiles = Array.from(tiles.values()).filter(t => 
                        !t.isDeactivated && 
                        t.colorIndex !== nextMissionIndex &&
                        (t.gridX !== player.gridX || t.gridY !== player.gridY)
                    );
                    if (allTiles.length > 0) {
                        targetTile = allTiles[Math.floor(Math.random() * allTiles.length)];
                    }
                }

                if (targetTile) {
                    targetTile.colorIndex = nextMissionIndex;
                    targetTile.mesh.material.color.set(currentThemeColors[nextMissionIndex]);
                }
            }
        }

        function updateWorld() {
            if (!player) return;
            const centerX = player.gridX;
            const centerY = player.gridY;
            const radius = GAME_CONFIG.GRID_RADIUS;

            for (let x = centerX - radius; x <= centerX + radius; x++) {
                for (let y = centerY - radius; y <= centerY + radius; y++) {
                    const dist = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
                    if (dist <= radius) {
                        const tileKey = `${x},${y}`;
                        if (!tiles.has(tileKey)) {
                            createTile(x, y, Math.floor(Math.random() * currentThemeColors.length));
                        }
                    }
                }
            }

            for (const [key, tile] of tiles.entries()) {
                const dist = Math.sqrt((tile.gridX - centerX)**2 + (tile.gridY - centerY)**2);
                if (dist > radius + 3) {
                    // 메모리 누수 방지: 타임아웃 정리
                    if (tile.reactivationTimeout) {
                        clearTimeout(tile.reactivationTimeout);
                        tile.reactivationTimeout = null;
                    }
                    scene.remove(tile.mesh);
                    tiles.delete(key);
                }
            }
            
            // 성능 최적화: 매 10프레임마다 미션 타일 체크
            frameCounter++;
            if (frameCounter % 10 === 0) {
                ensureMissionTileExists();
            }
        }

        function createTile(gridX, gridY, colorIndex) {
            const tileKey = `${gridX},${gridY}`;
            if (tiles.has(tileKey)) return;

            // 이벤트 블록 생성 확률 체크
            const eventBlockType = shouldCreateEventBlock();
            
            const geometry = new THREE.BoxGeometry(GAME_CONFIG.TILE_SIZE, 1, GAME_CONFIG.TILE_SIZE);
            let material;
            
            if (eventBlockType) {
                material = new THREE.MeshStandardMaterial({ 
                    color: EVENT_BLOCK_CONFIG.COLORS[eventBlockType],
                    emissive: EVENT_BLOCK_CONFIG.COLORS[eventBlockType],
                    emissiveIntensity: 0.3
                });
            } else {
                material = new THREE.MeshStandardMaterial({ color: currentThemeColors[colorIndex] });
            }
            
            const tileMesh = new THREE.Mesh(geometry, material);
            tileMesh.castShadow = true;

            const tileSpacing = GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_GAP;
            tileMesh.position.set(gridX * tileSpacing, 0, gridY * tileSpacing * -1);

            // 이벤트 블록에 심볼 추가
            if (eventBlockType) {
                addEventBlockSymbol(tileMesh, eventBlockType);
            }

            scene.add(tileMesh);
            const tileData = { 
                mesh: tileMesh, gridX, gridY, colorIndex, 
                isDeactivated: false, 
                targetY: 0,
                eventBlockType: eventBlockType || null
            };
            tiles.set(tileKey, tileData);
            return tileData;
        }

        function deactivateAndScheduleReactivation(tile) {
            tile.targetY = -GAME_CONFIG.TILE_SIZE;
            tile.mesh.material.color.set(DEACTIVATED_COLOR);
            tile.mesh.castShadow = false;

            const reactivationTimeout = setTimeout(() => {
                // 특수블록이든 일반블록이든 재활성화시 항상 일반 블록으로 복원
                tile.eventBlockType = null;
                tile.mesh.material.emissive.setHex(0x000000);
                tile.mesh.material.emissiveIntensity = 0;
                
                // 기존 심볼 제거
                if (tile.mesh.children.length > 0) {
                    tile.mesh.children.forEach(child => tile.mesh.remove(child));
                }
                
                let newColorIndex;
                do {
                    newColorIndex = Math.floor(Math.random() * currentThemeColors.length);
                } while (gameData.currentMission.includes(newColorIndex));
                
                tile.colorIndex = newColorIndex;
                tile.mesh.material.color.set(currentThemeColors[newColorIndex]);
                
                tile.isDeactivated = false;
                tile.targetY = 0;
                tile.mesh.castShadow = true;
                
                // 타임아웃 참조 제거
                tile.reactivationTimeout = null;
            }, GAME_CONFIG.TILE_RESPAWN_TIME);
            
            // 메모리 누수 방지를 위한 타임아웃 참조 저장
            tile.reactivationTimeout = reactivationTimeout;
        }

        function updateTiles() {
            for (const tile of tiles.values()) {
                if (tile.mesh.position.y !== tile.targetY) {
                    const newY = THREE.MathUtils.lerp(tile.mesh.position.y, tile.targetY, 0.1);
                    
                    // 성능 최적화: 목표 위치에 충분히 가까우면 정확한 위치로 설정
                    if (Math.abs(newY - tile.targetY) < 0.01) {
                        tile.mesh.position.y = tile.targetY;
                    } else {
                        tile.mesh.position.y = newY;
                    }
                }
            }
        }

        function updateMissionUI() {
            missionDisplay.innerHTML = '';
            const missionsToShow = gameData.currentMission.slice(0, 3);
            missionsToShow.forEach((colorIndex, index) => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'mission-color';
                colorDiv.style.backgroundColor = `#${currentThemeColors[colorIndex].toString(16).padStart(6, '0')}`;
                if (index === 0) {
                    colorDiv.classList.add('current');
                }
                missionDisplay.appendChild(colorDiv);
            });
        }
        
        function updateCamera() {
            if (!player) return;
            cameraTarget.lerp(player.mesh.position, 0.08);

            const angle = -Math.PI / 18;
            const distance = 80;

            camera.position.x = cameraTarget.x + Math.sin(angle) * distance;
            camera.position.z = cameraTarget.z + Math.cos(angle) * distance;
            camera.position.y = cameraTarget.y + 60;
            
            camera.lookAt(cameraTarget);

            directionalLight.position.x = cameraTarget.x + 30;
            directionalLight.position.y = cameraTarget.y + 50;
            directionalLight.position.z = cameraTarget.z + 20;
            directionalLight.target.position.copy(cameraTarget);
            directionalLight.target.updateMatrixWorld();
        }

        function togglePause() {
            const pauseButton = document.getElementById('pause-button');
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED';
                pausePanel.style.display = 'flex';
                pauseButton.textContent = '▶';
            } else if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                pausePanel.style.display = 'none';
                pauseButton.textContent = '||';
            }
            updateVirtualKeyboard();
        }

        function goHome() {
            gameState = 'MENU';
            pausePanel.style.display = 'none';
            hud.style.display = 'none';
            missionDisplay.style.display = 'none';
            mainMenu.style.display = 'flex';
            updateVirtualKeyboard();
        }

        // 튜토리얼 시스템 함수들
        function startTutorial() {
            console.log('튜토리얼 시작');
            gameState = 'TUTORIAL';
            tutorialData.isActive = true;
            tutorialData.currentStep = 0;
            tutorialData.hasPlayerMoved = false;
            tutorialData.hasSteppedCorrectTile = false;
            
            // UI 설정
            mainMenu.style.display = 'none';
            hud.style.display = 'flex';
            missionDisplay.style.display = 'flex';
            tutorialOverlay.style.display = 'block';
            
            // 게임 초기화 (시간 정지 상태)
            initializeGame();
            gameData.time = GAME_CONFIG.INITIAL_TIME;
            
            // 첫 번째 단계 표시
            updateTutorialUI();
            
            updateVirtualKeyboard();
        }
        
        function updateTutorialUI() {
            const step = tutorialSteps[tutorialData.currentStep];
            tutorialTitle.textContent = step.title;
            tutorialDescription.textContent = step.description;
            tutorialProgress.textContent = `${tutorialData.currentStep + 1}/${tutorialSteps.length}`;
            
            // 버튼 상태 업데이트
            tutorialPrevBtn.disabled = tutorialData.currentStep === 0;
            tutorialNextBtn.disabled = step.autoNext && !checkStepCompletion(step);
            
            if (step.isLastStep) {
                tutorialNextBtn.textContent = '완료';
            } else {
                tutorialNextBtn.textContent = '다음';
            }
        }
        
        function checkStepCompletion(step) {
            if (step.waitForMove) {
                return tutorialData.hasPlayerMoved;
            }
            if (step.waitForCorrectTile) {
                return tutorialData.hasSteppedCorrectTile;
            }
            return true;
        }
        
        function nextTutorialStep() {
            const currentStep = tutorialSteps[tutorialData.currentStep];
            
            if (currentStep.isLastStep) {
                exitTutorial();
                return;
            }
            
            if (tutorialData.currentStep < tutorialSteps.length - 1) {
                tutorialData.currentStep++;
                
                // 단계별 초기화
                const nextStep = tutorialSteps[tutorialData.currentStep];
                if (nextStep.waitForMove) {
                    tutorialData.hasPlayerMoved = false;
                }
                if (nextStep.waitForCorrectTile) {
                    tutorialData.hasSteppedCorrectTile = false;
                }
                
                // 강제 미션 설정
                if (nextStep.forcedMissionColor !== undefined) {
                    gameData.currentMission = [nextStep.forcedMissionColor];
                    updateMissionUI();
                }
                
                updateTutorialUI();
            }
        }
        
        function previousTutorialStep() {
            if (tutorialData.currentStep > 0) {
                tutorialData.currentStep--;
                updateTutorialUI();
            }
        }
        
        function exitTutorial() {
            console.log('튜토리얼 종료');
            tutorialData.isActive = false;
            tutorialOverlay.style.display = 'none';
            goHome();
        }
        
        function initializeGame() {
            // 기존 타일 정리
            tiles.forEach(tile => {
                if (tile.reactivationTimeout) {
                    clearTimeout(tile.reactivationTimeout);
                }
                scene.remove(tile.mesh);
            });
            tiles.clear();
            
            // 플레이어 생성
            if (player) {
                scene.remove(player.mesh);
            }
            createPlayer();
            
            // 기본 타일 생성
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    const colorIndex = Math.floor(Math.random() * currentThemeColors.length);
                    createTile(dx, dy, colorIndex);
                }
            }
            
            // 첫 미션 생성
            addNewMission();
            updateMissionUI();
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            if (gameState === 'PLAYING') {
                update(deltaTime);
                updateCamera();
            } else if (gameState === 'TUTORIAL') {
                // 튜토리얼 상태에서는 시간 흐름 정지, 플레이어 이동만 처리
                if (player) {
                    player.mesh.position.lerp(player.targetPosition, 0.2);
                    checkPlayerOnTile();
                    updateTiles();
                    updateCamera();
                }
            }
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
