<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>크로마 스텝 (Chroma Step) - MVP v2.6</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        :root {
            --color-bg: #121212; --color-text: #e0e0e0; --color-ui-bg: #1e1e1e;
            --color-cyan: #18ffff; --color-yellow: #ffc400;
        }

        body {
            margin: 0; padding: 0; font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--color-bg); color: var(--color-text);
            display: flex; justify-content: center; align-items: center;
            width: 100vw; height: 100vh; overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            width: 100%; max-width: 1000px; height: 100%;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; position: relative;
        }

        #canvas-container {
            width: 100%; height: 80%; background-color: #000;
            border-radius: 16px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            position: relative;
        }

        canvas { 
            display: block; width: 100%; height: 100%; border-radius: 16px;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .ui-panel {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(18, 18, 18, 0.95); display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 10; border-radius: 16px; text-align: center;
            padding: 20px; box-sizing: border-box; animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        .ui-panel h1 { font-size: 3rem; margin-bottom: 10px; letter-spacing: 2px; text-shadow: 0 0 10px var(--color-cyan); }
        .ui-panel p { font-size: 1.2rem; margin-bottom: 30px; }

        .ui-button {
            padding: 15px 30px; font-size: 1.2rem; font-weight: 700;
            color: var(--color-bg); background-color: var(--color-cyan);
            border: none; border-radius: 50px; cursor: pointer;
            transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(24, 255, 255, 0.3);
            margin: 5px;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .ui-button:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(24, 255, 255, 0.5); }
        
        #game-over-panel .stats { margin: 20px 0; font-size: 1.5rem; }
        #game-over-panel .new-highscore { color: var(--color-yellow); animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        
        /* 콤보 애니메이션 */
        @keyframes comboBoost {
            0% { transform: scale(1); color: inherit; }
            50% { transform: scale(1.2); color: var(--color-yellow); text-shadow: 0 0 10px var(--color-yellow); }
            100% { transform: scale(1); color: inherit; text-shadow: none; }
        }
        
        @keyframes screenFlash {
            0% { background-color: transparent; }
            50% { background-color: rgba(255, 255, 255, 0.1); }
            100% { background-color: transparent; }
        }
        
        .combo-boost {
            animation: comboBoost 0.5s ease-out;
        }
        
        .screen-flash {
            animation: screenFlash 0.3s ease-out;
        }
        
        /* 성공 타일 효과 */
        @keyframes tileSuccess {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-10px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }
        
        .tile-success {
            animation: tileSuccess 0.4s ease-out;
        }

        #hud {
            width: 100%; padding: 20px; box-sizing: border-box; position: absolute;
            top: 0; left: 0; z-index: 5; display: flex; justify-content: space-between;
            align-items: flex-start;
        }
        .hud-group { background-color: rgba(30, 30, 30, 0.8); padding: 10px 20px; border-radius: 12px; backdrop-filter: blur(5px); }
        #score-display, #combo-display { font-size: 1.5rem; font-weight: 700; }
        #combo-display { color: #ffab40; }
        #time-bar-container { width: 100%; height: 10px; background-color: rgba(255,255,255,0.2); border-radius: 5px; margin-top: 5px; }
        #time-bar { width: 100%; height: 100%; background-color: #69f0ae; border-radius: 5px; transition: width 0.1s linear; }
        #mission-display {
            display: flex; gap: 8px; padding: 10px; background-color: rgba(30, 30, 30, 0.8);
            border-radius: 12px; backdrop-filter: blur(5px); position: absolute;
            top: 20px; left: 50%; transform: translateX(-50%); pointer-events: none;
        }
        .mission-color {
            width: 40px; height: 40px; border-radius: 50%; border: 3px solid var(--color-text);
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        .mission-color.current { transform: scale(1.3); box-shadow: 0 0 20px #fff, 0 0 30px rgba(255, 255, 255, 0.5); }
        .mission-success-anim { animation: missionSuccess 0.5s ease-in-out; }
        @keyframes missionSuccess {
            0% { transform: scale(1.2); box-shadow: 0 0 15px #fff; }
            50% { transform: scale(1.5); box-shadow: 0 0 25px var(--color-yellow); }
            100% { transform: scale(0); opacity: 0; }
        }

        #pause-button {
            background-color: rgba(30, 30, 30, 0.8); backdrop-filter: blur(5px);
            border: 2px solid var(--color-text); color: var(--color-text);
            width: 50px; height: 50px; font-size: 1.5rem;
            border-radius: 50%; cursor: pointer;
            margin-left: 15px;
        }

        #settings-panel .theme-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 15px; width: 100%; max-width: 400px;
        }
        .theme-option { display: flex; align-items: center; width: 100%; }
        .theme-button {
            flex-grow: 1; text-align: left; border: 2px solid var(--color-text);
            background-color: transparent; color: var(--color-text);
        }
        .theme-button.selected {
            border-color: var(--color-cyan); background-color: rgba(24, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(24, 255, 255, 0.5);
        }
        .theme-preview { display: flex; margin-left: 15px; }
        .theme-swatch {
            width: 20px; height: 20px; border-radius: 50%;
            margin-left: -5px; border: 2px solid var(--color-bg);
        }

        /* 모바일 가상 키보드 스타일 */
        #virtual-keyboard {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 1000; pointer-events: none; display: none;
        }
        #virtual-keyboard.show {
            display: block;
        }
        .keyboard-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 10px; pointer-events: auto;
        }
        .keyboard-row {
            display: flex; gap: 15px; align-items: center;
        }
        .keyboard-key {
            width: 60px; height: 60px; border-radius: 50%;
            background-color: rgba(30, 30, 30, 0.9); color: var(--color-text);
            border: 2px solid var(--color-cyan); font-size: 20px; font-weight: bold;
            cursor: pointer; transition: all 0.2s ease;
            backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .keyboard-key:hover, .keyboard-key:active {
            background-color: var(--color-cyan); color: var(--color-bg);
            transform: scale(1.1); box-shadow: 0 6px 20px rgba(24, 255, 255, 0.4);
        }
        .keyboard-key:active {
            transform: scale(0.95);
        }
        

        /* 설정 패널 스타일 */
        .settings-section {
            margin-bottom: 30px; width: 100%; max-width: 400px;
        }
        .setting-item {
            display: flex; align-items: center; margin-bottom: 10px;
        }
        .setting-label {
            display: flex; align-items: center; cursor: pointer;
            font-size: 1.1rem; gap: 10px;
        }
        .setting-label input[type="checkbox"] {
            width: 20px; height: 20px; cursor: pointer;
        }

        /* 튜토리얼 모바일 최적화 */
        #tutorial-content {
            transition: all 0.3s ease;
        }
        
        /* 모바일 HUD 최적화 */
        @media (max-width: 768px) {
            #hud {
                padding: 5px;
            }
            .hud-group {
                padding: 5px 8px;
            }
            #score-display, #combo-display {
                font-size: 0.9rem;
            }
            #time-display {
                font-size: 0.9rem;
            }
            #mission-display {
                top: 5px;
                gap: 6px;
                padding: 8px;
            }
            .mission-color {
                width: 35px;
                height: 35px;
                border-width: 2px;
            }
            #pause-button {
                width: 35px;
                height: 35px;
                font-size: 1.2rem;
            }
            
            /* 튜토리얼 모바일 최적화 */
            #tutorial-content {
                top: 10px !important;
                max-width: 95% !important;
                padding: 15px !important;
                width: auto !important;
                max-height: 200px;
                overflow-y: auto;
            }
            
            #tutorial-title {
                font-size: 1.1rem !important;
            }
            
            #tutorial-description {
                font-size: 1rem !important;
                margin-bottom: 15px !important;
            }
            
            #tutorial-controls {
                flex-direction: column;
                gap: 8px !important;
            }
            
            #tutorial-controls > div {
                display: flex;
                justify-content: center;
                gap: 8px;
            }
            
            #tutorial-skip, #tutorial-prev, #tutorial-next {
                font-size: 0.9rem !important;
                padding: 8px 16px !important;
                flex: 1;
                max-width: 120px;
            }
        }
        
        /* 작은 모바일 화면 (아이폰 SE 등) */
        @media (max-width: 480px) {
            #tutorial-content {
                top: 5px !important;
                max-height: 180px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="canvas-container">
            <canvas id="game-canvas"></canvas>
            <div id="hud" style="display: none;">
                <div class="hud-group">
                    <div id="score-display">Score: 0</div>
                    <div id="combo-display">Combo: x1.0</div>
                </div>
                <div class="hud-group" style="display: flex; align-items: center;">
                    <div>
                        <div id="time-display">Time: 60.0</div>
                        <div id="time-bar-container"><div id="time-bar"></div></div>
                    </div>
                    <button id="pause-button">||</button>
                </div>
                <div id="invincibility-timer" style="display: none; position: absolute; top: 80px; right: 20px; background: rgba(255, 255, 0, 0.9); color: black; padding: 8px 16px; border-radius: 8px; font-size: 1.2rem; font-weight: bold; z-index: 1000;">
                    무적: <span id="invincibility-countdown">5</span>초
                </div>
            </div>
            <div id="mission-display" style="display: none;"></div>
            <div id="main-menu" class="ui-panel">
                <h1 style="font-size: 3.5rem; margin-bottom: 20px;">CHROMA STEP</h1>
                <div style="text-align: center; margin-bottom: 20px;">
                    <p style="font-size: 1.2rem; margin: 5px 0;">레벨 <span id="player-level">1</span></p>
                    <div style="width: 200px; height: 8px; background-color: rgba(255,255,255,0.2); border-radius: 4px; margin: 8px auto;">
                        <div id="exp-bar" style="width: 0%; height: 100%; background-color: var(--color-cyan); border-radius: 4px; transition: width 0.3s ease;"></div>
                    </div>
                    <p style="font-size: 0.9rem; margin: 5px 0; opacity: 0.8;"><span id="exp-display">0</span> / <span id="exp-needed">500</span> EXP</p>
                    <p style="font-size: 1rem; margin: 10px 0;">최고 점수: <span id="high-score">0</span></p>
                </div>
                <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                    <button id="start-button" class="ui-button">게임 시작</button>
                    <button id="tutorial-button" class="ui-button">튜토리얼</button>
                    <button id="settings-button" class="ui-button">설정</button>
                </div>
            </div>
            <div id="game-over-panel" class="ui-panel" style="display: none;">
                <h1>GAME OVER</h1>
                <div class="stats">
                    <p>Final Score: <span id="final-score">0</span></p>
                    <p class="new-highscore" style="display: none;">NEW HIGH SCORE!</p>
                    <p>Color Sparks: +<span id="sparks-earned">0</span></p>
                </div>
                <button id="restart-button" class="ui-button">다시 시작</button>
            </div>
            <div id="settings-panel" class="ui-panel" style="display: none;">
                <h1>설정</h1>
                <div class="settings-section">
                    <h2 style="font-size: 1.5rem; margin-bottom: 15px;">색상 테마</h2>
                    <div id="theme-container" class="theme-container"></div>
                </div>
                <div class="settings-section">
                    <h2 style="font-size: 1.5rem; margin-bottom: 15px;">모바일 설정</h2>
                    <div class="setting-item">
                        <label class="setting-label">
                            <input type="checkbox" id="virtual-keyboard-toggle" />
                            <span>가상 키보드 표시</span>
                        </label>
                    </div>
                </div>
                <button id="back-to-menu-button" class="ui-button">뒤로 가기</button>
            </div>
            <div id="pause-panel" class="ui-panel" style="display: none;">
                <h1>일시정지</h1>
                <button id="resume-button" class="ui-button">계속하기</button>
                <button id="home-button" class="ui-button">홈으로</button>
            </div>
            
            <!-- 튜토리얼 오버레이 -->
            <div id="tutorial-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 2000;">
                <div id="tutorial-content" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); max-width: 90%; width: 400px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);">
                    <div id="tutorial-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 id="tutorial-title" style="margin: 0; font-size: 1.3rem; color: #333; font-weight: bold;">튜토리얼</h3>
                        <span id="tutorial-progress" style="font-size: 1rem; color: #666; font-weight: bold;">1/7</span>
                    </div>
                    <div id="tutorial-description" style="margin-bottom: 20px; font-size: 1.1rem; color: #333; line-height: 1.5; text-align: center;">
                        게임을 시작하겠습니다!
                    </div>
                    <div id="tutorial-controls" style="display: flex; justify-content: space-between; gap: 10px;">
                        <button id="tutorial-skip" class="ui-button" style="background: #666; font-size: 1rem; padding: 10px 18px;">건너뛰기</button>
                        <div style="display: flex; gap: 10px;">
                            <button id="tutorial-prev" class="ui-button" style="font-size: 1rem; padding: 10px 18px;" disabled>이전</button>
                            <button id="tutorial-next" class="ui-button" style="font-size: 1rem; padding: 10px 18px;">다음</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 모바일 가상 키보드 -->
        <div id="virtual-keyboard" style="display: none;">
            <div class="keyboard-container">
                <div class="keyboard-row">
                    <button id="key-up" class="keyboard-key">↑</button>
                </div>
                <div class="keyboard-row">
                    <button id="key-left" class="keyboard-key">←</button>
                    <button id="key-down" class="keyboard-key">↓</button>
                    <button id="key-right" class="keyboard-key">→</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- 크로마 스텝 MVP 스크립트 ---
        // 기획서 버전 1.2 기반 / 수정사항 v2.6 (Color Fix)
        
        const scene = new THREE.Scene();
        const canvas = document.querySelector('#game-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        const camera = new THREE.OrthographicCamera(
            canvas.clientWidth / -2, canvas.clientWidth / 2,
            canvas.clientHeight / 2, canvas.clientHeight / -2,
            1, 1000
        );
        const cameraTarget = new THREE.Vector3(0, 0, 0);
        camera.position.set(0, 60, 60); 
        camera.lookAt(cameraTarget);

        // *** 수정: 색상 테마 개편 ***
        const COLOR_THEMES = {
            '선명한 무지개': [0xf44336, 0xff9800, 0xffeb3b, 0x4caf50, 0x2196f3, 0x3f51b5, 0x9c27b0],
            '네온의 꿈': [0xf06292, 0x4fc3f7, 0xffee58, 0x81c784, 0xba68c8, 0xff8a65, 0x4dd0e1],
            '사이버펑크 네온': [0xff00ff, 0x00ffff, 0x00ff00, 0xffff00, 0xff00aa, 0x00aaff, 0xaa00ff],
            '파스텔 정원': [0xef9a9a, 0xa5d6a7, 0xffcc80, 0x90caf9, 0xce93d8, 0xf48fb1, 0x80cbc4]
        };
        const DEACTIVATED_COLOR = 0x424242;
        let currentThemeColors = [];

        // 이벤트 블록 시스템
        const EVENT_BLOCK_TYPES = {
            TIME_GAIN: 'time_gain',
            TIME_LOSS: 'time_loss',
            INVINCIBILITY: 'invincibility'
        };

        const EVENT_BLOCK_CONFIG = {
            SPAWN_PROBABILITY: 0.02, // 2% 확률
            TIME_GAIN_AMOUNT: 5,
            TIME_LOSS_AMOUNT: 5,
            INVINCIBILITY_DURATION: 5,
            COLORS: {
                TIME_GAIN: 0x00ff00,    // 초록색
                TIME_LOSS: 0xff0000,    // 빨간색
                INVINCIBILITY: 0xffff00  // 노란색
            }
        };

        const GAME_CONFIG = {
            INITIAL_TIME: 45, BASE_SCORE_PER_TILE: 100,
            COMBO_MULTIPLIER: 0.15, MAX_COMBO_BONUS: 4.0,
            TIME_REWARD_BASE: 1.5,
            TILE_SIZE: 5, TILE_GAP: 1, GRID_RADIUS: 15, 
            TILE_RESPAWN_TIME: 4000,
            TIME_PENALTY_PER_MOVE: 1.0,
            TIME_DECAY_RATE: 1.2, // 시간당 추가 감소율
        };
        
        let gameState = 'MENU';
        // 보상 시스템 설정
        const REWARD_SYSTEM = {
            levels: [0, 500, 1200, 2000, 3500, 5500, 8000, 12000, 17000, 25000], // 레벨업 필요 점수
            skins: [
                { id: 'basic', name: '기본', color: 0xffffff, unlockLevel: 0 },
                { id: 'neon', name: '네온', color: 0x00ffff, unlockLevel: 2 },
                { id: 'gold', name: '황금', color: 0xffd700, unlockLevel: 4 },
                { id: 'rainbow', name: '무지개', color: 0xff69b4, unlockLevel: 6 },
                { id: 'crystal', name: '크리스탈', color: 0x9370db, unlockLevel: 8 }
            ]
        };

        // 미션 시스템 확장
        const MISSION_TYPES = {
            SINGLE_COLOR: 'single_color',      // 기존: 단일 색상
            SEQUENCE: 'sequence',              // 연속 색상 (빨강->파랑->초록)
            DOUBLE: 'double',                  // 같은 색상 2개 연속
            RAINBOW: 'rainbow',                // 모든 색상 한번씩
            TIME_RUSH: 'time_rush',            // 제한 시간 내 N개
            PATTERN: 'pattern'                 // 특정 패턴 (L자, 십자 등)
        };

        const MISSION_CONFIGS = {
            [MISSION_TYPES.SINGLE_COLOR]: {
                name: '색상 매칭',
                description: '지정된 색상 밟기',
                baseReward: 100,
                icon: '●'
            },
            [MISSION_TYPES.SEQUENCE]: {
                name: '색상 순서',
                description: '순서대로 색상 밟기',
                baseReward: 200,
                icon: '→'
            },
            [MISSION_TYPES.DOUBLE]: {
                name: '더블 매치',
                description: '같은 색상 2번 연속',
                baseReward: 150,
                icon: '●●'
            },
            [MISSION_TYPES.RAINBOW]: {
                name: '무지개',
                description: '모든 색상 한번씩',
                baseReward: 300,
                icon: '🌈'
            },
            [MISSION_TYPES.TIME_RUSH]: {
                name: '타임 러시',
                description: '5초 내 3개 색상',
                baseReward: 250,
                icon: '⏰'
            }
        };

        // 도전과제 시스템
        const ACHIEVEMENTS = {
            first_steps: { name: '첫 걸음', desc: '첫 번째 타일 밟기', target: 1, reward: 50 },
            combo_starter: { name: '콤보 시작', desc: '5콤보 달성', target: 5, reward: 100 },
            combo_master: { name: '콤보 마스터', desc: '15콤보 달성', target: 15, reward: 200 },
            combo_legend: { name: '콤보 전설', desc: '25콤보 달성', target: 25, reward: 500 },
            score_hunter: { name: '점수 사냥꾼', desc: '1000점 달성', target: 1000, reward: 100 },
            score_champion: { name: '점수 챔피언', desc: '5000점 달성', target: 5000, reward: 300 },
            time_survivor: { name: '시간 생존자', desc: '2분 생존', target: 120, reward: 200 },
            special_collector: { name: '특수 수집가', desc: '특수 블록 10개 밟기', target: 10, reward: 150 }
        };

        let gameData = {
            score: 0, time: GAME_CONFIG.INITIAL_TIME, combo: 1,
            currentMission: [],
            highScore: 0, colorSparks: 0,
            isInvincible: false,
            invincibilityEndTime: 0,
            // 진행 시스템
            totalScore: 0, // 누적 점수
            level: 1,
            experience: 0,
            currentSkin: 'basic',
            // 도전과제 시스템
            achievements: {},
            sessionStats: {
                tilesPressed: 0,
                maxCombo: 0,
                specialBlocksCollected: 0,
                survivalTime: 0
            },
            // 확장된 미션 시스템
            currentMissionType: MISSION_TYPES.SINGLE_COLOR,
            missionProgress: [],
            rainbowProgress: new Set(),
            timeRushStartTime: 0,
            missionStartTime: 0
        };
        let gameSettings = {
            theme: '선명한 무지개',
            showVirtualKeyboard: true
        };
        
        // 튜토리얼 시스템
        const tutorialSteps = [
            {
                id: 0,
                title: "게임 소개",
                description: "CHROMA STEP에 오신 걸 환영합니다! 색깔 블록을 밟아 미션을 완료하는 리듬 게임입니다.",
                highlight: null,
                playerCanMove: false,
                autoNext: false
            },
            {
                id: 1,
                title: "이동 방법",
                description: "방향키 또는 WASD로 이동할 수 있습니다. 한 번 이동해보세요!",
                highlight: "player",
                playerCanMove: true,
                autoNext: true,
                waitForMove: true
            },
            {
                id: 2,
                title: "미션 시스템",
                description: "화면 상단에 표시된 색깔이 현재 미션입니다. 이 색깔과 일치하는 블록을 찾아 밟으세요!",
                highlight: "mission",
                playerCanMove: true,
                autoNext: false,
                forcedMissionColor: 0
            },
            {
                id: 3,
                title: "올바른 블록 밟기",
                description: "미션 색깔과 일치하는 블록을 밟으면 점수를 얻습니다. 한 번 밟아보세요!",
                highlight: "tile",
                playerCanMove: true,
                autoNext: true,
                waitForCorrectTile: true
            },
            {
                id: 4,
                title: "콤보 시스템",
                description: "연속으로 성공하면 콤보가 증가하여 더 많은 점수를 얻을 수 있습니다!",
                highlight: "combo",
                playerCanMove: true,
                autoNext: false
            },
            {
                id: 5,
                title: "특수 블록",
                description: "가끔 특수 블록이 나타납니다. 초록색(+T)은 시간 증가, 빨간색(-T)은 시간 감소, 노란색(★)은 무적 상태입니다.",
                highlight: null,
                playerCanMove: true,
                autoNext: false
            },
            {
                id: 6,
                title: "시간 관리",
                description: "시간이 다 떨어지면 게임 오버! 올바른 블록을 밟으면 시간이 회복됩니다. 이제 실제 게임을 시작해보세요!",
                highlight: "time",
                playerCanMove: true,
                autoNext: false,
                isLastStep: true
            }
        ];
        
        let tutorialData = {
            isActive: false,
            currentStep: 0,
            hasPlayerMoved: false,
            hasSteppedCorrectTile: false
        };
        
        let player, clock = new THREE.Clock(), tiles = new Map(), directionalLight;
        let frameCounter = 0; // 성능 최적화용 프레임 카운터
        
        // 이벤트 블록 생성 확률 체크
        function shouldCreateEventBlock() {
            if (Math.random() < EVENT_BLOCK_CONFIG.SPAWN_PROBABILITY) {
                const types = Object.values(EVENT_BLOCK_TYPES);
                return types[Math.floor(Math.random() * types.length)];
            }
            return null;
        }
        
        // 이벤트 블록에 심볼 추가
        function addEventBlockSymbol(tileMesh, eventBlockType) {
            const symbolGeometry = new THREE.PlaneGeometry(4, 4); // 크기 증가
            let symbolText = '';
            
            switch(eventBlockType) {
                case EVENT_BLOCK_TYPES.TIME_GAIN:
                    symbolText = '+T';
                    break;
                case EVENT_BLOCK_TYPES.TIME_LOSS:
                    symbolText = '-T';
                    break;
                case EVENT_BLOCK_TYPES.INVINCIBILITY:
                    symbolText = '★';
                    break;
            }
            
            // 텍스트 텍스처 생성
            const canvas = document.createElement('canvas');
            canvas.width = 256; // 해상도 증가
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // 검은색 배경 추가 (대비 향상)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 256, 256);
            
            // 흰색 테두리 추가
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 8;
            ctx.font = 'bold 120px Arial'; // 폰트 크기 증가
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeText(symbolText, 128, 128);
            
            // 흰색 텍스트
            ctx.fillStyle = 'white';
            ctx.fillText(symbolText, 128, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            const symbolMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                alphaTest: 0.1
            });
            
            const symbolMesh = new THREE.Mesh(symbolGeometry, symbolMaterial);
            symbolMesh.position.set(0, 0.6, 0);
            symbolMesh.rotation.x = -Math.PI / 2;
            tileMesh.add(symbolMesh);
        }
        
        // 이벤트 블록 효과 처리
        function handleEventBlock(eventBlockType) {
            console.log('이벤트 블록 효과 발동:', eventBlockType); // 디버깅용
            
            switch(eventBlockType) {
                case EVENT_BLOCK_TYPES.TIME_GAIN:
                    gameData.time += EVENT_BLOCK_CONFIG.TIME_GAIN_AMOUNT;
                    console.log('시간 +5초 획득! 현재 시간:', gameData.time);
                    createParticleEffect('time_gain');
                    break;
                case EVENT_BLOCK_TYPES.TIME_LOSS:
                    gameData.time -= EVENT_BLOCK_CONFIG.TIME_LOSS_AMOUNT;
                    if (gameData.time < 0) gameData.time = 0;
                    console.log('시간 -5초 손실! 현재 시간:', gameData.time);
                    createParticleEffect('time_loss');
                    break;
                case EVENT_BLOCK_TYPES.INVINCIBILITY:
                    gameData.isInvincible = true;
                    gameData.invincibilityEndTime = Date.now() + (EVENT_BLOCK_CONFIG.INVINCIBILITY_DURATION * 1000);
                    console.log('무적 상태 활성화! 5초간 지속');
                    createParticleEffect('invincibility');
                    activateInvincibilityEffect();
                    break;
            }
        }
        
        // 무적 효과 시각화
        function activateInvincibilityEffect() {
            if (player && player.mesh) {
                player.mesh.material.emissive.setHex(0xffff00);
                player.mesh.material.emissiveIntensity = 0.8;
                console.log('무적 효과 활성화됨'); // 디버깅용
                
                // 무적 타이머 UI 표시
                invincibilityTimer.style.display = 'block';
                updateInvincibilityTimer();
            }
        }
        
        // 무적 효과 해제
        function deactivateInvincibilityEffect() {
            if (player && player.mesh) {
                player.mesh.material.emissive.setHex(0x000000);
                player.mesh.material.emissiveIntensity = 0;
                console.log('무적 효과 해제됨'); // 디버깅용
                
                // 무적 타이머 UI 숨기기
                invincibilityTimer.style.display = 'none';
            }
        }
        
        // 무적 타이머 업데이트
        function updateInvincibilityTimer() {
            if (gameData.isInvincible) {
                const remaining = Math.max(0, (gameData.invincibilityEndTime - Date.now()) / 1000);
                invincibilityCountdown.textContent = Math.ceil(remaining);
                
                if (remaining > 0) {
                    setTimeout(updateInvincibilityTimer, 100);
                }
            }
        }
        
        // 파티클 효과 생성
        function createParticleEffect(type, position) {
            if (!player) return; // 플레이어가 없으면 파티클 생성 안함
            
            const particleGroup = new THREE.Group();
            const particleCount = type === 'success' ? 20 : 30; // 성공 효과는 적은 파티클
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8); // 크기 증가
                let particleMaterial;
                
                switch(type) {
                    case 'time_gain':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x00ff00, 
                            transparent: true,
                            emissive: 0x00ff00,
                            emissiveIntensity: 0.5
                        });
                        break;
                    case 'time_loss':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xff0000, 
                            transparent: true,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.5
                        });
                        break;
                    case 'invincibility':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xffff00, 
                            transparent: true,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.5
                        });
                        break;
                    case 'success':
                        particleMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xffffff, 
                            transparent: true,
                            emissive: 0xffffff,
                            emissiveIntensity: 0.8
                        });
                        break;
                }
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 위치 설정 (position이 제공되면 사용, 아니면 플레이어 위치)
                const basePos = position || player.mesh.position;
                particle.position.copy(basePos);
                particle.position.y += 2; // 위쪽에서 시작
                
                if (type === 'success') {
                    // 성공 효과는 더 화려하게
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 12 + 3,
                        (Math.random() - 0.5) * 10
                    );
                } else {
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 15,
                        Math.random() * 8 + 2,
                        (Math.random() - 0.5) * 15
                    );
                }
                
                particle.life = type === 'success' ? 1.5 : 2.0;
                particleGroup.add(particle);
            }
            
            scene.add(particleGroup);
            
            // 파티클 애니메이션
            const animateParticles = () => {
                particleGroup.children.forEach(particle => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(0.03));
                    particle.velocity.y -= 0.3; // 중력 증가
                    particle.life -= 0.03;
                    particle.material.opacity = particle.life / (type === 'success' ? 1.5 : 2.0);
                    
                    if (particle.life <= 0) {
                        particleGroup.remove(particle);
                    }
                });
                
                if (particleGroup.children.length > 0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particleGroup);
                }
            };
            
            animateParticles();
        }

        const hud = document.getElementById('hud');
        const mainMenu = document.getElementById('main-menu');
        const gameOverPanel = document.getElementById('game-over-panel');
        const settingsPanel = document.getElementById('settings-panel');
        const pausePanel = document.getElementById('pause-panel');
        const scoreDisplay = document.getElementById('score-display');
        const comboDisplay = document.getElementById('combo-display');
        const timeDisplay = document.getElementById('time-display');
        const timeBar = document.getElementById('time-bar');
        const missionDisplay = document.getElementById('mission-display');
        const highScoreDisplay = document.getElementById('high-score');
        const finalScoreDisplay = document.getElementById('final-score');
        const sparksEarnedDisplay = document.getElementById('sparks-earned');
        const newHighScoreBadge = gameOverPanel.querySelector('.new-highscore');
        const virtualKeyboard = document.getElementById('virtual-keyboard');
        const keyboardToggle = document.getElementById('virtual-keyboard-toggle');
        const invincibilityTimer = document.getElementById('invincibility-timer');
        const invincibilityCountdown = document.getElementById('invincibility-countdown');
        const tutorialOverlay = document.getElementById('tutorial-overlay');
        const tutorialTitle = document.getElementById('tutorial-title');
        const tutorialDescription = document.getElementById('tutorial-description');
        const tutorialProgress = document.getElementById('tutorial-progress');
        const tutorialPrevBtn = document.getElementById('tutorial-prev');
        const tutorialNextBtn = document.getElementById('tutorial-next');
        const tutorialSkipBtn = document.getElementById('tutorial-skip');
        const playerLevelDisplay = document.getElementById('player-level');
        const expBar = document.getElementById('exp-bar');
        const expDisplay = document.getElementById('exp-display');
        const expNeededDisplay = document.getElementById('exp-needed');

        function init() {
            scene.background = new THREE.Color(0x121212);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(30, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            const groundGeometry = new THREE.PlaneGeometry(5000, 5000);
            const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.51;
            ground.receiveShadow = true;
            scene.add(ground);

            loadGameData();
            setupSettingsPanel();
            setupVirtualKeyboard();
            applyTheme();

            // UI 버튼에 터치 피드백 적용
            addTouchFeedback(document.getElementById('start-button'), startGame);
            addTouchFeedback(document.getElementById('tutorial-button'), startTutorial);
            addTouchFeedback(document.getElementById('settings-button'), showSettingsPanel);
            addTouchFeedback(document.getElementById('back-to-menu-button'), showMainMenu);
            addTouchFeedback(document.getElementById('restart-button'), startGame);
            addTouchFeedback(document.getElementById('pause-button'), togglePause);
            addTouchFeedback(document.getElementById('resume-button'), togglePause);
            addTouchFeedback(document.getElementById('home-button'), goHome);
            
            // 튜토리얼 버튼 이벤트 (터치 피드백 추가)
            addTouchFeedback(tutorialPrevBtn, previousTutorialStep);
            addTouchFeedback(tutorialNextBtn, nextTutorialStep);
            addTouchFeedback(tutorialSkipBtn, exitTutorial);
            
            window.addEventListener('keydown', handleInput);
            window.addEventListener('resize', () => {
                onWindowResize();
                updateVirtualKeyboard();
            });

            onWindowResize();
            updateVirtualKeyboard(); // 초기화 시 가상 키보드 상태 업데이트
            animate();
        }

        function isMobileDevice() {
            const widthCheck = window.innerWidth <= 768;
            const userAgentCheck = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const result = widthCheck || userAgentCheck;
            
            console.log('모바일 감지:', {
                windowWidth: window.innerWidth,
                widthCheck: widthCheck,
                userAgent: navigator.userAgent,
                userAgentCheck: userAgentCheck,
                finalResult: result
            });
            
            return result;
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            renderer.setSize(width, height);
            
            // 모바일 최적화: 화면 크기에 따라 줌 레벨 조정
            const zoom = isMobileDevice() ? 0.035 : 0.025; // 모바일에서는 더 넓게
            
            camera.left = -width * zoom; camera.right = width * zoom;
            camera.top = height * zoom; camera.bottom = -height * zoom;
            camera.updateProjectionMatrix();
        }

        function loadGameData() {
            const savedData = localStorage.getItem('chromaStepData');
            console.log('설정 로드:', savedData);
            
            if (savedData) {
                const parsed = JSON.parse(savedData);
                gameData.highScore = parsed.highScore || 0;
                gameData.colorSparks = parsed.colorSparks || 0;
                gameData.totalScore = parsed.totalScore || 0;
                gameData.level = parsed.level || 1;
                gameData.currentSkin = parsed.currentSkin || 'basic';
                gameData.achievements = parsed.achievements || {};
                gameSettings.theme = parsed.theme || '선명한 무지개';
                gameSettings.showVirtualKeyboard = parsed.showVirtualKeyboard !== undefined ? parsed.showVirtualKeyboard : true;
            } else {
                console.log('저장된 설정이 없음, 기본값 사용');
                gameSettings.showVirtualKeyboard = true;
            }
            
            // 임시: 가상 키보드 강제 활성화 (테스트용)
            console.log('원래 설정:', gameSettings.showVirtualKeyboard);
            gameSettings.showVirtualKeyboard = true;
            console.log('강제 설정 후:', gameSettings.showVirtualKeyboard);
            
            // 진행도 업데이트
            updateProgressDisplay();
            
            console.log('최종 설정:', gameSettings);
        }

        function saveGameData() {
            localStorage.setItem('chromaStepData', JSON.stringify({
                highScore: gameData.highScore,
                colorSparks: gameData.colorSparks,
                totalScore: gameData.totalScore,
                level: gameData.level,
                currentSkin: gameData.currentSkin,
                achievements: gameData.achievements,
                theme: gameSettings.theme,
                showVirtualKeyboard: gameSettings.showVirtualKeyboard
            }));
        }

        function showSettingsPanel() {
            mainMenu.style.display = 'none';
            settingsPanel.style.display = 'flex';
        }
        function showMainMenu() {
            settingsPanel.style.display = 'none';
            mainMenu.style.display = 'flex';
        }
        function setupSettingsPanel() {
            const container = document.getElementById('theme-container');
            container.innerHTML = '';
            Object.keys(COLOR_THEMES).forEach(themeName => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'theme-option';

                const button = document.createElement('button');
                button.className = 'ui-button theme-button';
                button.textContent = themeName;
                if (themeName === gameSettings.theme) {
                    button.classList.add('selected');
                }
                button.addEventListener('click', () => {
                    gameSettings.theme = themeName;
                    applyTheme();
                    saveGameData();
                    container.querySelectorAll('.theme-button').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                });

                const previewDiv = document.createElement('div');
                previewDiv.className = 'theme-preview';
                COLOR_THEMES[themeName].forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'theme-swatch';
                    swatch.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}`;
                    previewDiv.appendChild(swatch);
                });
                
                optionDiv.appendChild(button);
                optionDiv.appendChild(previewDiv);
                container.appendChild(optionDiv);
            });
            
            // 가상 키보드 체크박스 상태 설정
            console.log('체크박스 설정:', gameSettings.showVirtualKeyboard);
            keyboardToggle.checked = gameSettings.showVirtualKeyboard;
        }
        function applyTheme() {
            currentThemeColors = COLOR_THEMES[gameSettings.theme];
        }

        function clearAllTimeouts() {
            // 모든 타일의 타임아웃을 정리
            for (const tile of tiles.values()) {
                if (tile.reactivationTimeout) {
                    clearTimeout(tile.reactivationTimeout);
                    tile.reactivationTimeout = null;
                }
            }
        }

        function updateVirtualKeyboard() {
            const isMobile = isMobileDevice();
            const showKeyboard = gameSettings.showVirtualKeyboard;
            const isPlaying = gameState === 'PLAYING';
            
            console.log('=== 가상 키보드 디버깅 ===');
            console.log('isMobile:', isMobile);
            console.log('showKeyboard:', showKeyboard);
            console.log('isPlaying:', isPlaying);
            console.log('virtualKeyboard element:', virtualKeyboard);
            
            // CSS 우선순위 문제 해결: 인라인 스타일 제거
            virtualKeyboard.style.display = '';
            
            if (isMobile && showKeyboard && isPlaying) {
                virtualKeyboard.classList.add('show');
                console.log('✅ 키보드 표시 조건 만족 - 표시함');
            } else {
                virtualKeyboard.classList.remove('show');
                console.log('❌ 키보드 표시 조건 불만족 - 숨김');
                console.log('조건 체크: isMobile &&', isMobile, '&& showKeyboard &&', showKeyboard, '&& isPlaying &&', isPlaying);
            }
            
            console.log('최종 classList:', virtualKeyboard.classList);
        }

        // 햅틱 피드백 함수
        function vibrate(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        // 콤보 시각적 피드백 함수
        function triggerComboFeedback(comboValue) {
            // 콤보 표시 애니메이션
            const comboDisplay = document.getElementById('combo-display');
            comboDisplay.classList.remove('combo-boost');
            void comboDisplay.offsetWidth; // 강제 리플로우로 애니메이션 재시작
            comboDisplay.classList.add('combo-boost');
            
            // 콤보가 높을수록 더 강한 효과
            if (comboValue >= 5) {
                // 화면 플래시 효과
                const canvasContainer = document.getElementById('canvas-container');
                canvasContainer.classList.remove('screen-flash');
                void canvasContainer.offsetWidth;
                canvasContainer.classList.add('screen-flash');
                
                // 카메라 흔들림 효과 (간단한 구현)
                if (camera) {
                    const originalY = camera.position.y;
                    camera.position.y += Math.random() * 2 - 1;
                    setTimeout(() => {
                        camera.position.y = originalY;
                    }, 100);
                }
            }
            
            // 높은 콤보에서 더 강한 진동
            if (comboValue >= 10) {
                vibrate([50, 30, 50, 30, 50]);
            } else if (comboValue >= 5) {
                vibrate([80, 50, 80]);
            }
        }
        
        // 타일 성공 시각적 효과
        function triggerTileSuccessEffect(tilePosition) {
            // 파티클 효과는 기존 함수 활용
            createParticleEffect('success', tilePosition);
            
            // 플레이어 바운스 효과
            if (player && player.mesh) {
                const originalY = player.mesh.position.y;
                const bounceHeight = 3;
                const duration = 400; // 밀리초
                const startTime = Date.now();
                
                const animateBounce = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 사인 함수로 자연스러운 바운스
                    const bounceY = Math.sin(progress * Math.PI) * bounceHeight;
                    player.mesh.position.y = originalY + bounceY;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateBounce);
                    } else {
                        player.mesh.position.y = originalY; // 원래 위치로 복원
                    }
                };
                
                animateBounce();
            }
        }

        // 도전과제 시스템 함수들
        function checkAchievements() {
            for (const [id, achievement] of Object.entries(ACHIEVEMENTS)) {
                if (gameData.achievements[id]) continue; // 이미 달성된 도전과제는 건너뛰기
                
                let isAchieved = false;
                
                switch (id) {
                    case 'first_steps':
                        isAchieved = gameData.sessionStats.tilesPressed >= achievement.target;
                        break;
                    case 'combo_starter':
                    case 'combo_master':
                    case 'combo_legend':
                        isAchieved = gameData.sessionStats.maxCombo >= achievement.target;
                        break;
                    case 'score_hunter':
                    case 'score_champion':
                        isAchieved = gameData.score >= achievement.target;
                        break;
                    case 'time_survivor':
                        isAchieved = gameData.sessionStats.survivalTime >= achievement.target;
                        break;
                    case 'special_collector':
                        isAchieved = gameData.sessionStats.specialBlocksCollected >= achievement.target;
                        break;
                }
                
                if (isAchieved) {
                    unlockAchievement(id, achievement);
                }
            }
        }

        function unlockAchievement(id, achievement) {
            gameData.achievements[id] = true;
            gameData.totalScore += achievement.reward;
            
            showAchievementNotification(achievement);
            vibrate([50, 100, 50, 100, 150]); // 도전과제 달성 진동
            
            // 레벨 체크 (보상 점수로 인한)
            const oldLevel = gameData.level;
            gameData.level = calculateLevel(gameData.totalScore);
            if (gameData.level > oldLevel) {
                showLevelUpNotification(gameData.level);
            }
            
            updateProgressDisplay();
        }

        function showAchievementNotification(achievement) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 120px; left: 50%; transform: translateX(-50%);
                z-index: 9999; background: linear-gradient(45deg, #ff6b35, #f7931e);
                color: white; padding: 12px 25px; border-radius: 20px;
                font-size: 1.1rem; font-weight: bold; text-align: center;
                box-shadow: 0 4px 20px rgba(255, 107, 53, 0.5);
                animation: fadeIn 0.5s ease-out;
                max-width: 300px; word-wrap: break-word;
            `;
            notification.innerHTML = `
                🏆 도전과제 달성!<br>
                <span style="font-size: 1rem;">${achievement.name}</span><br>
                <span style="font-size: 0.9rem; opacity: 0.9;">+${achievement.reward} EXP</span>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 4000);
        }

        // 시간 기반 미션 체크
        function checkTimeBasedMissions() {
            const currentMission = gameData.currentMission[0];
            if (!currentMission || currentMission.type !== MISSION_TYPES.TIME_RUSH) return;
            
            const elapsed = Date.now() - currentMission.startTime;
            if (elapsed > currentMission.timeLimit) {
                // 타임 러시 실패
                showMissionFailedEffect('시간 초과!');
                gameData.currentMission.shift();
                addNewMission();
                ensureMissionTileExists();
                updateMissionUI();
                
                // 콤보 리셋 및 페널티
                gameData.combo = 1;
                gameData.time -= 3; // 3초 페널티
                vibrate([200, 100, 200, 100, 200]);
            } else {
                // UI 업데이트 (타이머)
                updateMissionUI();
            }
        }
        
        function showMissionFailedEffect(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                z-index: 9999; background: linear-gradient(45deg, #ff4444, #cc0000);
                color: white; padding: 15px 30px; border-radius: 20px;
                font-size: 1.3rem; font-weight: bold; text-align: center;
                box-shadow: 0 8px 30px rgba(255, 68, 68, 0.5);
                animation: fadeIn 0.3s ease-out;
                pointer-events: none;
            `;
            notification.innerHTML = `
                <div style="font-size: 1.5rem; margin-bottom: 5px;">❌</div>
                <div>${message}</div>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 1500);
        }

        function updateSessionStats() {
            // 세션 중 최대 콤보 업데이트
            if (gameData.combo > gameData.sessionStats.maxCombo) {
                gameData.sessionStats.maxCombo = gameData.combo;
            }
            
            // 생존 시간 업데이트 (시작 시간 - 현재 시간)
            gameData.sessionStats.survivalTime = GAME_CONFIG.INITIAL_TIME - gameData.time;
        }

        // 레벨 시스템 함수들
        function calculateLevel(totalScore) {
            for (let i = REWARD_SYSTEM.levels.length - 1; i >= 0; i--) {
                if (totalScore >= REWARD_SYSTEM.levels[i]) {
                    return i + 1;
                }
            }
            return 1;
        }

        function getExpForNextLevel(level) {
            if (level >= REWARD_SYSTEM.levels.length) {
                return REWARD_SYSTEM.levels[REWARD_SYSTEM.levels.length - 1];
            }
            return REWARD_SYSTEM.levels[level];
        }

        function updatePlayerProgress(scoreGained) {
            const oldLevel = gameData.level;
            gameData.totalScore += scoreGained;
            gameData.level = calculateLevel(gameData.totalScore);
            
            // 레벨업 체크
            if (gameData.level > oldLevel) {
                showLevelUpNotification(gameData.level);
                vibrate([100, 50, 100, 50, 200]); // 레벨업 진동
                
                // 새로운 스킨 언락 체크
                const unlockedSkins = REWARD_SYSTEM.skins.filter(skin => 
                    skin.unlockLevel === gameData.level
                );
                if (unlockedSkins.length > 0) {
                    showSkinUnlockNotification(unlockedSkins[0]);
                }
            }
            
            updateProgressDisplay();
        }

        function updateProgressDisplay() {
            if (!playerLevelDisplay) return;
            
            playerLevelDisplay.textContent = gameData.level;
            
            const currentLevelReq = REWARD_SYSTEM.levels[gameData.level - 1] || 0;
            const nextLevelReq = getExpForNextLevel(gameData.level);
            const progress = gameData.totalScore - currentLevelReq;
            const needed = nextLevelReq - currentLevelReq;
            
            if (expDisplay) expDisplay.textContent = progress;
            if (expNeededDisplay) expNeededDisplay.textContent = needed;
            
            if (expBar) {
                const percentage = Math.min((progress / needed) * 100, 100);
                expBar.style.width = `${percentage}%`;
            }
        }

        function showLevelUpNotification(newLevel) {
            // 간단한 레벨업 알림 (화면 상단에 표시)
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                z-index: 9999; background: linear-gradient(45deg, var(--color-cyan), var(--color-yellow));
                color: black; padding: 15px 30px; border-radius: 25px;
                font-size: 1.3rem; font-weight: bold; text-align: center;
                box-shadow: 0 4px 20px rgba(0, 255, 255, 0.5);
                animation: fadeIn 0.5s ease-out;
            `;
            notification.textContent = `🎉 레벨 ${newLevel} 달성! 🎉`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }

        function showSkinUnlockNotification(skin) {
            // 스킨 언락 알림
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
                z-index: 9999; background: rgba(0, 0, 0, 0.9);
                color: var(--color-yellow); padding: 12px 25px; border-radius: 20px;
                font-size: 1.1rem; font-weight: bold; text-align: center;
                border: 2px solid var(--color-yellow);
                animation: fadeIn 0.5s ease-out;
            `;
            notification.textContent = `✨ ${skin.name} 스킨 언락! ✨`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }

        function applySkinToPlayer() {
            if (!player || !player.mesh) return;
            
            const currentSkin = REWARD_SYSTEM.skins.find(skin => skin.id === gameData.currentSkin);
            if (currentSkin) {
                player.mesh.material.color.setHex(currentSkin.color);
                // 특별한 효과들
                if (currentSkin.id === 'rainbow') {
                    // 무지개 효과는 시간에 따라 색상 변화
                    player.mesh.material.emissive.setHex(0x404040);
                    player.mesh.material.emissiveIntensity = 0.3;
                } else if (currentSkin.id === 'crystal') {
                    // 크리스탈 효과
                    player.mesh.material.transparent = true;
                    player.mesh.material.opacity = 0.8;
                    player.mesh.material.emissive.setHex(currentSkin.color);
                    player.mesh.material.emissiveIntensity = 0.2;
                }
            }
        }

        // 터치 피드백 함수
        function addTouchFeedback(element, callback, vibrationPattern = [50]) {
            let touchStarted = false;
            
            // 터치 시작
            element.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStarted = true;
                element.style.transform = 'scale(0.95)';
                element.style.filter = 'brightness(1.2)';
                vibrate(vibrationPattern);
            }, { passive: false });
            
            // 터치 끝
            element.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (touchStarted) {
                    element.style.transform = '';
                    element.style.filter = '';
                    callback();
                    touchStarted = false;
                }
            }, { passive: false });
            
            // 터치 취소 (화면 밖으로 드래그 등)
            element.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                element.style.transform = '';
                element.style.filter = '';
                touchStarted = false;
            }, { passive: false });
            
            // 마우스 이벤트도 유지 (데스크톱 호환성)
            element.addEventListener('click', callback);
        }

        function setupVirtualKeyboard() {
            // 가상 키보드 버튼 이벤트 설정 (터치 최적화)
            const keyUp = document.getElementById('key-up');
            const keyDown = document.getElementById('key-down');
            const keyLeft = document.getElementById('key-left');
            const keyRight = document.getElementById('key-right');
            
            if (keyUp) addTouchFeedback(keyUp, () => handleVirtualKey('ArrowUp'), [30]);
            if (keyDown) addTouchFeedback(keyDown, () => handleVirtualKey('ArrowDown'), [30]);
            if (keyLeft) addTouchFeedback(keyLeft, () => handleVirtualKey('ArrowLeft'), [30]);
            if (keyRight) addTouchFeedback(keyRight, () => handleVirtualKey('ArrowRight'), [30]);
            
            // 체크박스 이벤트 설정
            if (keyboardToggle) {
                keyboardToggle.addEventListener('change', (e) => {
                    console.log('체크박스 변경:', e.target.checked);
                    gameSettings.showVirtualKeyboard = e.target.checked;
                    updateVirtualKeyboard();
                    saveGameData();
                });
            } else {
                console.log('⚠️ 체크박스 엘리먼트가 없습니다!');
            }
        }

        function handleVirtualKey(key) {
            if (gameState !== 'PLAYING') return;
            
            // 버튼 누름 효과
            const button = document.getElementById(`key-${key.replace('Arrow', '').toLowerCase()}`);
            if (button) {
                button.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    button.style.transform = '';
                }, 100);
            }
            
            // 키 입력 시뮬레이션
            handleInput({ key: key });
        }

        function startGame() {
            mainMenu.style.display = 'none';
            gameOverPanel.style.display = 'none';
            pausePanel.style.display = 'none';
            hud.style.display = 'flex';
            missionDisplay.style.display = 'flex';
            document.getElementById('pause-button').textContent = '||';

            gameData.score = 0;
            gameData.time = GAME_CONFIG.INITIAL_TIME;
            gameData.combo = 1;
            gameData.currentMission = [];
            
            // 세션 통계 초기화
            gameData.sessionStats = {
                tilesPressed: 0,
                maxCombo: 0,
                specialBlocksCollected: 0,
                survivalTime: 0
            };
            
            // 확장된 미션 시스템 초기화
            gameData.missionProgress = [];
            gameData.rainbowProgress = new Set();
            gameData.timeRushStartTime = 0;
            gameData.missionStartTime = Date.now();
            
            // 메모리 누수 방지: 모든 타임아웃 정리
            clearAllTimeouts();
            
            tiles.forEach(tile => scene.remove(tile.mesh));
            tiles.clear();
            if (player) scene.remove(player.mesh);

            createPlayer();
            camera.position.set(0, 60, 60);
            cameraTarget.set(0, 0, 0);
            updateCamera();

            for (let i = 0; i < 3; i++) {
                addNewMission();
            }
            updateWorld(); // 이미 ensureMissionTileExists를 호출함
            
            const startTile = tiles.get('0,0');
            if (startTile && startTile.colorIndex === gameData.currentMission[0]) {
                let newColorIndex;
                do {
                    newColorIndex = Math.floor(Math.random() * currentThemeColors.length);
                } while (newColorIndex === gameData.currentMission[0]);
                startTile.colorIndex = newColorIndex;
                startTile.mesh.material.color.set(currentThemeColors[newColorIndex]);
            }

            gameState = 'PLAYING';
            updateVirtualKeyboard();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            
            // 메모리 누수 방지: 모든 타임아웃 정리
            clearAllTimeouts();
            
            hud.style.display = 'none';
            missionDisplay.style.display = 'none';
            gameOverPanel.style.display = 'flex';

            finalScoreDisplay.textContent = gameData.score.toLocaleString();
            if (gameData.score > gameData.highScore) {
                gameData.highScore = gameData.score;
                newHighScoreBadge.style.display = 'block';
            } else {
                newHighScoreBadge.style.display = 'none';
            }
            
            const sparks = Math.floor(gameData.score / 100);
            sparksEarnedDisplay.textContent = sparks.toLocaleString();
            gameData.colorSparks += sparks;
            
            // 진행도 업데이트 (현재 게임 점수로)
            updatePlayerProgress(gameData.score);
            
            saveGameData();
            highScoreDisplay.textContent = gameData.highScore.toLocaleString();
            updateVirtualKeyboard();
        }

        function update(deltaTime) {
            if (gameState !== 'PLAYING' || !player) return;

            // 동적 시간 감소 (시간이 지날수록 더 빠르게 감소)
            const elapsedTime = GAME_CONFIG.INITIAL_TIME - gameData.time;
            const difficultyMultiplier = 1 + (elapsedTime / 60) * (GAME_CONFIG.TIME_DECAY_RATE - 1);
            
            gameData.time -= deltaTime * difficultyMultiplier;
            if (gameData.time <= 0) {
                gameData.time = 0;
                gameOver();
            }
            
            // 무적 상태 확인
            if (gameData.isInvincible && Date.now() > gameData.invincibilityEndTime) {
                gameData.isInvincible = false;
                deactivateInvincibilityEffect();
            }
            
            player.mesh.position.lerp(player.targetPosition, 0.2);
            checkPlayerOnTile();
            updateWorld();
            updateUI();
            updateTiles();
            
            // 세션 통계 및 도전과제 업데이트
            updateSessionStats();
            
            // 타임 러시 미션 시간 체크
            checkTimeBasedMissions();
            
            // 주기적으로 도전과제 체크 (시간 기반 도전과제 등)
            if (Math.floor(gameData.time) !== Math.floor(gameData.time + deltaTime)) {
                checkAchievements();
            }
        }

        function updateUI() {
            scoreDisplay.textContent = `Score: ${gameData.score.toLocaleString()}`;
            const comboBonus = 1.0 + (gameData.combo - 1) * GAME_CONFIG.COMBO_MULTIPLIER;
            comboDisplay.textContent = `Combo: x${Math.min(comboBonus, GAME_CONFIG.MAX_COMBO_BONUS).toFixed(1)}`;
            timeDisplay.textContent = `Time: ${gameData.time.toFixed(1)}`;
            timeBar.style.width = `${(gameData.time / GAME_CONFIG.INITIAL_TIME) * 100}%`;
        }
        
        function createPlayer() {
            const geometry = new THREE.SphereGeometry(GAME_CONFIG.TILE_SIZE * 0.4, 32, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, emissive: 0xcccccc, metalness: 0.1, roughness: 0.2
            });
            const playerY = 0.5 + (GAME_CONFIG.TILE_SIZE * 0.4);
            player = {
                mesh: new THREE.Mesh(geometry, material),
                gridX: 0, gridY: 0,
                targetPosition: new THREE.Vector3(0, playerY, 0)
            };
            player.mesh.castShadow = true;
            player.mesh.position.copy(player.targetPosition);
            scene.add(player.mesh);
            
            // 현재 스킨 적용
            applySkinToPlayer();
        }

        function handleInput(event) {
            if (gameState !== 'PLAYING' && gameState !== 'TUTORIAL') return;
            
            // 튜토리얼 상태에서는 플레이어 이동 허용 여부 확인
            if (gameState === 'TUTORIAL') {
                const currentStep = tutorialSteps[tutorialData.currentStep];
                if (!currentStep.playerCanMove) return;
            }
            
            let dx = 0, dy = 0;
            switch (event.key) {
                case 'ArrowUp':    dy = 1; break;
                case 'ArrowDown':  dy = -1; break;
                case 'ArrowLeft':  dx = -1; break;
                case 'ArrowRight': dx = 1; break;
                default: return;
            }
            
            const nextGridX = player.gridX + dx;
            const nextGridY = player.gridY + dy;
            const nextTileKey = `${nextGridX},${nextGridY}`;
            const nextTile = tiles.get(nextTileKey);

            // 무적 상태일 때는 비활성화된 블록 위로도 이동 가능
            if (nextTile && (!nextTile.isDeactivated || gameData.isInvincible)) {
                player.gridX = nextGridX;
                player.gridY = nextGridY;
                const tileSpacing = GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_GAP;
                player.targetPosition.x = player.gridX * tileSpacing;
                player.targetPosition.z = player.gridY * tileSpacing * -1;
                
                // 튜토리얼 상태에서 이동 완료 표시
                if (gameState === 'TUTORIAL') {
                    tutorialData.hasPlayerMoved = true;
                    const currentStep = tutorialSteps[tutorialData.currentStep];
                    if (currentStep.autoNext && currentStep.waitForMove) {
                        updateTutorialUI();
                    }
                }
            }
        }
        
        function checkPlayerOnTile() {
            const tileKey = `${player.gridX},${player.gridY}`;
            const currentTile = tiles.get(tileKey);
            
            if (currentTile && !currentTile.isDeactivated) {
                handleStepOnTile(currentTile);
            }
            // 무적 상태에서 비활성화된 블록 위에 있을 때는 아무 효과 없음
        }

        function handleStepOnTile(tile) {
            tile.isDeactivated = true; 
            
            // 세션 통계 업데이트 (모든 타일에 대해)
            gameData.sessionStats.tilesPressed++;
            
            // 이벤트 블록 처리
            if (tile.eventBlockType) {
                gameData.sessionStats.specialBlocksCollected++;
                handleEventBlock(tile.eventBlockType);
                deactivateAndScheduleReactivation(tile);
                vibrate([80, 50, 80]); // 특수 블록 진동 패턴
                
                // 도전과제 체크
                checkAchievements();
                return;
            }
            
            const result = checkMissionProgress(tile.colorIndex);

            if (result.success) {
                // 성공 시 햅틱 피드백
                vibrate([100]);
                
                // 미션 완료 시 추가 보상
                let scoreMultiplier = 1.0;
                if (result.missionCompleted) {
                    scoreMultiplier = MISSION_CONFIGS[result.missionType]?.baseReward / 100 || 1.0;
                    
                    // 미션 완료 시각적 효과
                    showMissionCompleteEffect(result.missionType);
                }

                gameData.score += Math.round(GAME_CONFIG.BASE_SCORE_PER_TILE * scoreMultiplier * (1.0 + (gameData.combo - 1) * GAME_CONFIG.COMBO_MULTIPLIER));
                gameData.combo++;
                
                // 콤보 시각적 피드백 트리거
                triggerComboFeedback(gameData.combo);
                
                // 타일 성공 효과
                triggerTileSuccessEffect(player.mesh.position);
                
                // 튜토리얼 상태가 아닐 때만 시간 업데이트
                if (gameState !== 'TUTORIAL') {
                    gameData.time += GAME_CONFIG.TIME_REWARD_BASE * scoreMultiplier;
                }
                
                // 튜토리얼 상태에서 올바른 타일 밟기 완료 표시
                if (gameState === 'TUTORIAL') {
                    tutorialData.hasSteppedCorrectTile = true;
                    const currentStep = tutorialSteps[tutorialData.currentStep];
                    if (currentStep.autoNext && currentStep.waitForCorrectTile) {
                        updateTutorialUI();
                    }
                }
                
                // 미션 완료 시 새 미션 생성
                if (result.missionCompleted) {
                    gameData.currentMission.shift();
                    addNewMission();
                    ensureMissionTileExists();
                }
                
                updateMissionUI();
                
                // 도전과제 체크 (성공적인 타일 밟기 후)
                checkAchievements();
            } else {
                // 실패 시 햅틱 피드백
                vibrate([200, 100, 200]);
                gameData.combo = 1;
                
                // 미션 실패 시 진행도 리셋 (특정 미션 타입)
                if (result.resetProgress) {
                    resetCurrentMissionProgress();
                }
                
                // 튜토리얼 상태가 아닐 때만 시간 페널티
                if (gameState !== 'TUTORIAL') {
                    gameData.time -= GAME_CONFIG.TIME_PENALTY_PER_MOVE;
                }
                updateMissionUI();
            }
            
            deactivateAndScheduleReactivation(tile);
        }

        // 새로운 미션 생성 (확장된 버전)
        function generateNewMission() {
            // 레벨에 따른 미션 타입 확률 조정
            const level = gameData.level;
            let missionTypeWeights = {
                [MISSION_TYPES.SINGLE_COLOR]: 60,
                [MISSION_TYPES.DOUBLE]: level >= 2 ? 20 : 0,
                [MISSION_TYPES.SEQUENCE]: level >= 3 ? 15 : 0,
                [MISSION_TYPES.RAINBOW]: level >= 5 ? 10 : 0,
                [MISSION_TYPES.TIME_RUSH]: level >= 4 ? 5 : 0
            };
            
            // 가중치 기반 랜덤 선택
            const totalWeight = Object.values(missionTypeWeights).reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            
            for (const [type, weight] of Object.entries(missionTypeWeights)) {
                random -= weight;
                if (random <= 0) {
                    return generateMissionOfType(type);
                }
            }
            
            // 폴백: 기본 미션
            return generateMissionOfType(MISSION_TYPES.SINGLE_COLOR);
        }
        
        function generateMissionOfType(missionType) {
            const colors = currentThemeColors;
            
            switch (missionType) {
                case MISSION_TYPES.SINGLE_COLOR:
                    return {
                        type: missionType,
                        target: [Math.floor(Math.random() * colors.length)],
                        progress: 0,
                        maxProgress: 1
                    };
                    
                case MISSION_TYPES.DOUBLE:
                    const colorIndex = Math.floor(Math.random() * colors.length);
                    return {
                        type: missionType,
                        target: [colorIndex, colorIndex],
                        progress: 0,
                        maxProgress: 2
                    };
                    
                case MISSION_TYPES.SEQUENCE:
                    const sequenceLength = 3;
                    const sequence = [];
                    for (let i = 0; i < sequenceLength; i++) {
                        sequence.push(Math.floor(Math.random() * colors.length));
                    }
                    return {
                        type: missionType,
                        target: sequence,
                        progress: 0,
                        maxProgress: sequenceLength
                    };
                    
                case MISSION_TYPES.RAINBOW:
                    return {
                        type: missionType,
                        target: Array.from({length: colors.length}, (_, i) => i),
                        progress: 0,
                        maxProgress: colors.length,
                        collected: new Set()
                    };
                    
                case MISSION_TYPES.TIME_RUSH:
                    return {
                        type: missionType,
                        target: Array.from({length: 3}, () => Math.floor(Math.random() * colors.length)),
                        progress: 0,
                        maxProgress: 3,
                        timeLimit: 5000, // 5초
                        startTime: Date.now()
                    };
                    
                default:
                    return generateMissionOfType(MISSION_TYPES.SINGLE_COLOR);
            }
        }

        // 미션 진행도 체크 함수
        function checkMissionProgress(colorIndex) {
            const currentMission = gameData.currentMission[0];
            if (!currentMission) return { success: false };
            
            switch (currentMission.type) {
                case MISSION_TYPES.SINGLE_COLOR:
                    if (colorIndex === currentMission.target[0]) {
                        return { success: true, missionCompleted: true, missionType: currentMission.type };
                    }
                    break;
                    
                case MISSION_TYPES.DOUBLE:
                    if (colorIndex === currentMission.target[currentMission.progress]) {
                        currentMission.progress++;
                        if (currentMission.progress >= currentMission.maxProgress) {
                            return { success: true, missionCompleted: true, missionType: currentMission.type };
                        }
                        return { success: true, missionCompleted: false };
                    } else {
                        return { success: false, resetProgress: true };
                    }
                    break;
                    
                case MISSION_TYPES.SEQUENCE:
                    if (colorIndex === currentMission.target[currentMission.progress]) {
                        currentMission.progress++;
                        if (currentMission.progress >= currentMission.maxProgress) {
                            return { success: true, missionCompleted: true, missionType: currentMission.type };
                        }
                        return { success: true, missionCompleted: false };
                    } else {
                        return { success: false, resetProgress: true };
                    }
                    break;
                    
                case MISSION_TYPES.RAINBOW:
                    if (currentMission.target.includes(colorIndex) && !currentMission.collected.has(colorIndex)) {
                        currentMission.collected.add(colorIndex);
                        currentMission.progress++;
                        if (currentMission.progress >= currentMission.maxProgress) {
                            return { success: true, missionCompleted: true, missionType: currentMission.type };
                        }
                        return { success: true, missionCompleted: false };
                    }
                    break;
                    
                case MISSION_TYPES.TIME_RUSH:
                    // 시간 체크
                    const elapsed = Date.now() - currentMission.startTime;
                    if (elapsed > currentMission.timeLimit) {
                        return { success: false, resetProgress: true };
                    }
                    
                    if (currentMission.target.includes(colorIndex)) {
                        // 이미 밟은 색상인지 체크
                        const targetIndex = currentMission.target.findIndex((color, idx) => 
                            color === colorIndex && idx >= currentMission.progress
                        );
                        
                        if (targetIndex !== -1) {
                            currentMission.progress++;
                            if (currentMission.progress >= currentMission.maxProgress) {
                                return { success: true, missionCompleted: true, missionType: currentMission.type };
                            }
                            return { success: true, missionCompleted: false };
                        }
                    }
                    break;
            }
            
            return { success: false };
        }
        
        function resetCurrentMissionProgress() {
            const currentMission = gameData.currentMission[0];
            if (!currentMission) return;
            
            currentMission.progress = 0;
            if (currentMission.collected) {
                currentMission.collected.clear();
            }
            if (currentMission.type === MISSION_TYPES.TIME_RUSH) {
                currentMission.startTime = Date.now();
            }
        }
        
        function showMissionCompleteEffect(missionType) {
            const config = MISSION_CONFIGS[missionType];
            if (!config) return;
            
            // 화면 중앙에 미션 완료 알림
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                z-index: 9999; background: linear-gradient(45deg, #ff6b35, #f7931e);
                color: white; padding: 20px 40px; border-radius: 25px;
                font-size: 1.5rem; font-weight: bold; text-align: center;
                box-shadow: 0 8px 30px rgba(255, 107, 53, 0.5);
                animation: fadeIn 0.3s ease-out;
                pointer-events: none;
            `;
            notification.innerHTML = `
                <div style="font-size: 2rem; margin-bottom: 10px;">${config.icon}</div>
                <div>${config.name} 완료!</div>
                <div style="font-size: 1rem; opacity: 0.9;">+${config.baseReward} 점수!</div>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out forwards';
                setTimeout(() => notification.remove(), 500);
            }, 1500);
            
            // 특별한 진동 패턴
            vibrate([100, 50, 100, 50, 200]);
        }

        // 기존 함수 호환성을 위한 래퍼
        function addNewMission() {
            const newMission = generateNewMission();
            gameData.currentMission.push(newMission);
            gameData.missionStartTime = Date.now();
        }

        function ensureMissionTileExists() {
            const currentMission = gameData.currentMission[0];
            if (!currentMission) return;
            
            const requiredColors = getRequiredColorsForMission(currentMission);
            
            for (const colorIndex of requiredColors) {
                if (!hasAccessibleTileOfColor(colorIndex)) {
                    createTileOfColor(colorIndex);
                }
            }
        }
        
        function getRequiredColorsForMission(mission) {
            switch (mission.type) {
                case MISSION_TYPES.SINGLE_COLOR:
                    return [mission.target[0]];
                    
                case MISSION_TYPES.DOUBLE:
                    return [mission.target[mission.progress]];
                    
                case MISSION_TYPES.SEQUENCE:
                    return [mission.target[mission.progress]];
                    
                case MISSION_TYPES.RAINBOW:
                    return mission.target.filter(color => !mission.collected.has(color));
                    
                case MISSION_TYPES.TIME_RUSH:
                    return mission.target.filter((color, idx) => idx >= mission.progress);
                    
                default:
                    return [];
            }
        }
        
        function hasAccessibleTileOfColor(colorIndex) {
            for (const tile of tiles.values()) {
                if (tile.colorIndex === colorIndex && !tile.isDeactivated) {
                    const distance = Math.sqrt((tile.gridX - player.gridX)**2 + (tile.gridY - player.gridY)**2);
                    if (distance <= 10) { // 적당한 거리 내에 있음
                        return true;
                    }
                }
            }
            return false;
        }
        
        function createTileOfColor(colorIndex) {
            // 접근 가능한 타일을 우선적으로 선택 (플레이어 주변 타일)
            const accessibleTiles = [];
            const nearbyTiles = [];
            
            for (const tile of tiles.values()) {
                if (!tile.isDeactivated && !tile.eventBlockType) {
                    const distance = Math.sqrt((tile.gridX - player.gridX)**2 + (tile.gridY - player.gridY)**2);
                    
                    // 플레이어와 인접한 타일 (거리 1-3)
                    if (distance <= 3 && distance > 0) {
                        accessibleTiles.push(tile);
                    } 
                    // 그 외 근처 타일 (거리 4-8)
                    else if (distance <= 8 && distance > 3) {
                        nearbyTiles.push(tile);
                    }
                }
            }

            let targetTile = null;
            
            // 1순위: 접근 가능한 타일
            if (accessibleTiles.length > 0) {
                targetTile = accessibleTiles[Math.floor(Math.random() * accessibleTiles.length)];
            } 
            // 2순위: 근처 타일
            else if (nearbyTiles.length > 0) {
                targetTile = nearbyTiles[Math.floor(Math.random() * nearbyTiles.length)];
            } 
            // 3순위: 아무 타일
            else {
                const allTiles = Array.from(tiles.values()).filter(t => 
                    !t.isDeactivated && 
                    !t.eventBlockType &&
                    (t.gridX !== player.gridX || t.gridY !== player.gridY)
                );
                if (allTiles.length > 0) {
                    targetTile = allTiles[Math.floor(Math.random() * allTiles.length)];
                }
            }

            if (targetTile) {
                targetTile.colorIndex = colorIndex;
                targetTile.mesh.material.color.set(currentThemeColors[colorIndex]);
            }
        }

        function updateWorld() {
            if (!player) return;
            const centerX = player.gridX;
            const centerY = player.gridY;
            const radius = GAME_CONFIG.GRID_RADIUS;

            for (let x = centerX - radius; x <= centerX + radius; x++) {
                for (let y = centerY - radius; y <= centerY + radius; y++) {
                    const dist = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
                    if (dist <= radius) {
                        const tileKey = `${x},${y}`;
                        if (!tiles.has(tileKey)) {
                            createTile(x, y, Math.floor(Math.random() * currentThemeColors.length));
                        }
                    }
                }
            }

            for (const [key, tile] of tiles.entries()) {
                const dist = Math.sqrt((tile.gridX - centerX)**2 + (tile.gridY - centerY)**2);
                if (dist > radius + 3) {
                    // 메모리 누수 방지: 타임아웃 정리
                    if (tile.reactivationTimeout) {
                        clearTimeout(tile.reactivationTimeout);
                        tile.reactivationTimeout = null;
                    }
                    scene.remove(tile.mesh);
                    tiles.delete(key);
                }
            }
            
            // 성능 최적화: 매 10프레임마다 미션 타일 체크
            frameCounter++;
            if (frameCounter % 10 === 0) {
                ensureMissionTileExists();
            }
        }

        function createTile(gridX, gridY, colorIndex) {
            const tileKey = `${gridX},${gridY}`;
            if (tiles.has(tileKey)) return;

            // 이벤트 블록 생성 확률 체크
            const eventBlockType = shouldCreateEventBlock();
            
            const geometry = new THREE.BoxGeometry(GAME_CONFIG.TILE_SIZE, 1, GAME_CONFIG.TILE_SIZE);
            let material;
            
            if (eventBlockType) {
                material = new THREE.MeshStandardMaterial({ 
                    color: EVENT_BLOCK_CONFIG.COLORS[eventBlockType],
                    emissive: EVENT_BLOCK_CONFIG.COLORS[eventBlockType],
                    emissiveIntensity: 0.3
                });
            } else {
                material = new THREE.MeshStandardMaterial({ color: currentThemeColors[colorIndex] });
            }
            
            const tileMesh = new THREE.Mesh(geometry, material);
            tileMesh.castShadow = true;

            const tileSpacing = GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_GAP;
            tileMesh.position.set(gridX * tileSpacing, 0, gridY * tileSpacing * -1);

            // 이벤트 블록에 심볼 추가
            if (eventBlockType) {
                addEventBlockSymbol(tileMesh, eventBlockType);
            }

            scene.add(tileMesh);
            const tileData = { 
                mesh: tileMesh, gridX, gridY, colorIndex, 
                isDeactivated: false, 
                targetY: 0,
                eventBlockType: eventBlockType || null
            };
            tiles.set(tileKey, tileData);
            return tileData;
        }

        function deactivateAndScheduleReactivation(tile) {
            // 타일 밟기 애니메이션 효과
            tile.mesh.material.emissive.setHex(0xffffff);
            tile.mesh.material.emissiveIntensity = 0.5;
            
            // 즉시 원래 색으로 복원한 후 서서히 어둡게
            setTimeout(() => {
                tile.mesh.material.emissive.setHex(0x000000);
                tile.mesh.material.emissiveIntensity = 0;
            }, 200);
            
            tile.targetY = -GAME_CONFIG.TILE_SIZE;
            tile.mesh.material.color.set(DEACTIVATED_COLOR);
            tile.mesh.castShadow = false;

            const reactivationTimeout = setTimeout(() => {
                // 특수블록이든 일반블록이든 재활성화시 항상 일반 블록으로 복원
                tile.eventBlockType = null;
                tile.mesh.material.emissive.setHex(0x000000);
                tile.mesh.material.emissiveIntensity = 0;
                
                // 기존 심볼 제거
                if (tile.mesh.children.length > 0) {
                    tile.mesh.children.forEach(child => tile.mesh.remove(child));
                }
                
                let newColorIndex;
                do {
                    newColorIndex = Math.floor(Math.random() * currentThemeColors.length);
                } while (gameData.currentMission.includes(newColorIndex));
                
                tile.colorIndex = newColorIndex;
                tile.mesh.material.color.set(currentThemeColors[newColorIndex]);
                
                tile.isDeactivated = false;
                tile.targetY = 0;
                tile.mesh.castShadow = true;
                
                // 타임아웃 참조 제거
                tile.reactivationTimeout = null;
            }, GAME_CONFIG.TILE_RESPAWN_TIME);
            
            // 메모리 누수 방지를 위한 타임아웃 참조 저장
            tile.reactivationTimeout = reactivationTimeout;
        }

        function updateTiles() {
            for (const tile of tiles.values()) {
                if (tile.mesh.position.y !== tile.targetY) {
                    const newY = THREE.MathUtils.lerp(tile.mesh.position.y, tile.targetY, 0.1);
                    
                    // 성능 최적화: 목표 위치에 충분히 가까우면 정확한 위치로 설정
                    if (Math.abs(newY - tile.targetY) < 0.01) {
                        tile.mesh.position.y = tile.targetY;
                    } else {
                        tile.mesh.position.y = newY;
                    }
                }
            }
        }

        function updateMissionUI() {
            missionDisplay.innerHTML = '';
            
            const currentMission = gameData.currentMission[0];
            if (!currentMission) return;
            
            // 미션 타입 표시
            const typeIndicator = document.createElement('div');
            typeIndicator.style.cssText = `
                font-size: 1.2rem; margin-bottom: 5px; color: var(--color-text);
                text-align: center; font-weight: bold;
            `;
            const config = MISSION_CONFIGS[currentMission.type];
            typeIndicator.textContent = `${config.icon} ${config.name}`;
            missionDisplay.appendChild(typeIndicator);
            
            // 미션별 UI 표시
            const missionContainer = document.createElement('div');
            missionContainer.style.cssText = 'display: flex; gap: 6px; align-items: center; justify-content: center;';
            
            switch (currentMission.type) {
                case MISSION_TYPES.SINGLE_COLOR:
                    createColorIndicator(missionContainer, currentMission.target[0], true);
                    break;
                    
                case MISSION_TYPES.DOUBLE:
                    currentMission.target.forEach((colorIndex, idx) => {
                        createColorIndicator(missionContainer, colorIndex, idx === currentMission.progress);
                    });
                    break;
                    
                case MISSION_TYPES.SEQUENCE:
                    currentMission.target.forEach((colorIndex, idx) => {
                        createColorIndicator(missionContainer, colorIndex, idx === currentMission.progress);
                        if (idx < currentMission.target.length - 1) {
                            const arrow = document.createElement('div');
                            arrow.textContent = '→';
                            arrow.style.color = 'var(--color-text)';
                            missionContainer.appendChild(arrow);
                        }
                    });
                    break;
                    
                case MISSION_TYPES.RAINBOW:
                    currentMission.target.forEach(colorIndex => {
                        const isCollected = currentMission.collected.has(colorIndex);
                        createColorIndicator(missionContainer, colorIndex, !isCollected, isCollected);
                    });
                    break;
                    
                case MISSION_TYPES.TIME_RUSH:
                    // 타이머 표시
                    const elapsed = Date.now() - currentMission.startTime;
                    const remaining = Math.max(0, currentMission.timeLimit - elapsed);
                    const timerDiv = document.createElement('div');
                    timerDiv.style.cssText = `
                        background: ${remaining < 2000 ? '#ff4444' : '#44ff44'};
                        color: black; padding: 2px 8px; border-radius: 10px;
                        font-size: 0.9rem; font-weight: bold; margin-right: 8px;
                    `;
                    timerDiv.textContent = `${Math.ceil(remaining / 1000)}s`;
                    missionContainer.appendChild(timerDiv);
                    
                    // 필요한 색상들
                    currentMission.target.forEach((colorIndex, idx) => {
                        createColorIndicator(missionContainer, colorIndex, idx === currentMission.progress);
                    });
                    break;
            }
            
            // 진행도 표시
            if (currentMission.maxProgress > 1) {
                const progressDiv = document.createElement('div');
                progressDiv.style.cssText = `
                    font-size: 0.8rem; color: var(--color-text);
                    margin-top: 3px; text-align: center;
                `;
                progressDiv.textContent = `${currentMission.progress}/${currentMission.maxProgress}`;
                missionDisplay.appendChild(progressDiv);
            }
            
            missionDisplay.appendChild(missionContainer);
        }
        
        function createColorIndicator(container, colorIndex, isCurrent = false, isCompleted = false) {
            const colorDiv = document.createElement('div');
            colorDiv.className = 'mission-color';
            
            if (isCompleted) {
                // 완료된 색상은 체크마크 표시
                colorDiv.style.cssText = `
                    background: linear-gradient(45deg, #4caf50, #81c784);
                    border: 3px solid var(--color-text);
                    display: flex; align-items: center; justify-content: center;
                    font-size: 1.2rem; color: white;
                `;
                colorDiv.textContent = '✓';
            } else {
                colorDiv.style.backgroundColor = `#${currentThemeColors[colorIndex].toString(16).padStart(6, '0')}`;
                if (isCurrent) {
                    colorDiv.classList.add('current');
                } else {
                    colorDiv.style.opacity = '0.6';
                }
            }
            
            container.appendChild(colorDiv);
        }
        
        function updateCamera() {
            if (!player) return;
            cameraTarget.lerp(player.mesh.position, 0.08);

            const angle = -Math.PI / 18;
            const distance = 80;

            camera.position.x = cameraTarget.x + Math.sin(angle) * distance;
            camera.position.z = cameraTarget.z + Math.cos(angle) * distance;
            camera.position.y = cameraTarget.y + 60;
            
            camera.lookAt(cameraTarget);

            directionalLight.position.x = cameraTarget.x + 30;
            directionalLight.position.y = cameraTarget.y + 50;
            directionalLight.position.z = cameraTarget.z + 20;
            directionalLight.target.position.copy(cameraTarget);
            directionalLight.target.updateMatrixWorld();
        }

        function togglePause() {
            const pauseButton = document.getElementById('pause-button');
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED';
                pausePanel.style.display = 'flex';
                pauseButton.textContent = '▶';
            } else if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                pausePanel.style.display = 'none';
                pauseButton.textContent = '||';
            }
            updateVirtualKeyboard();
        }

        function goHome() {
            gameState = 'MENU';
            pausePanel.style.display = 'none';
            hud.style.display = 'none';
            missionDisplay.style.display = 'none';
            mainMenu.style.display = 'flex';
            updateVirtualKeyboard();
        }

        // 튜토리얼 시스템 함수들
        function startTutorial() {
            console.log('튜토리얼 시작');
            gameState = 'TUTORIAL';
            tutorialData.isActive = true;
            tutorialData.currentStep = 0;
            tutorialData.hasPlayerMoved = false;
            tutorialData.hasSteppedCorrectTile = false;
            
            // UI 설정
            mainMenu.style.display = 'none';
            hud.style.display = 'flex';
            missionDisplay.style.display = 'flex';
            tutorialOverlay.style.display = 'block';
            
            // 게임 초기화 (시간 정지 상태)
            initializeGame();
            gameData.time = GAME_CONFIG.INITIAL_TIME;
            
            // 첫 번째 단계 표시
            updateTutorialUI();
            
            updateVirtualKeyboard();
        }
        
        function updateTutorialUI() {
            const step = tutorialSteps[tutorialData.currentStep];
            tutorialTitle.textContent = step.title;
            tutorialDescription.textContent = step.description;
            tutorialProgress.textContent = `${tutorialData.currentStep + 1}/${tutorialSteps.length}`;
            
            // 버튼 상태 업데이트
            tutorialPrevBtn.disabled = tutorialData.currentStep === 0;
            tutorialNextBtn.disabled = step.autoNext && !checkStepCompletion(step);
            
            if (step.isLastStep) {
                tutorialNextBtn.textContent = '완료';
            } else {
                tutorialNextBtn.textContent = '다음';
            }
        }
        
        function checkStepCompletion(step) {
            if (step.waitForMove) {
                return tutorialData.hasPlayerMoved;
            }
            if (step.waitForCorrectTile) {
                return tutorialData.hasSteppedCorrectTile;
            }
            return true;
        }
        
        function nextTutorialStep() {
            const currentStep = tutorialSteps[tutorialData.currentStep];
            
            if (currentStep.isLastStep) {
                exitTutorial();
                return;
            }
            
            if (tutorialData.currentStep < tutorialSteps.length - 1) {
                tutorialData.currentStep++;
                
                // 단계별 초기화
                const nextStep = tutorialSteps[tutorialData.currentStep];
                if (nextStep.waitForMove) {
                    tutorialData.hasPlayerMoved = false;
                }
                if (nextStep.waitForCorrectTile) {
                    tutorialData.hasSteppedCorrectTile = false;
                }
                
                // 강제 미션 설정
                if (nextStep.forcedMissionColor !== undefined) {
                    gameData.currentMission = [nextStep.forcedMissionColor];
                    updateMissionUI();
                }
                
                updateTutorialUI();
            }
        }
        
        function previousTutorialStep() {
            if (tutorialData.currentStep > 0) {
                tutorialData.currentStep--;
                updateTutorialUI();
            }
        }
        
        function exitTutorial() {
            console.log('튜토리얼 종료');
            tutorialData.isActive = false;
            tutorialOverlay.style.display = 'none';
            goHome();
        }
        
        function initializeGame() {
            // 기존 타일 정리
            tiles.forEach(tile => {
                if (tile.reactivationTimeout) {
                    clearTimeout(tile.reactivationTimeout);
                }
                scene.remove(tile.mesh);
            });
            tiles.clear();
            
            // 플레이어 생성
            if (player) {
                scene.remove(player.mesh);
            }
            createPlayer();
            
            // 기본 타일 생성
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    const colorIndex = Math.floor(Math.random() * currentThemeColors.length);
                    createTile(dx, dy, colorIndex);
                }
            }
            
            // 첫 미션 생성
            addNewMission();
            updateMissionUI();
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            if (gameState === 'PLAYING') {
                update(deltaTime);
                updateCamera();
            } else if (gameState === 'TUTORIAL') {
                // 튜토리얼 상태에서는 시간 흐름 정지, 플레이어 이동만 처리
                if (player) {
                    player.mesh.position.lerp(player.targetPosition, 0.2);
                    checkPlayerOnTile();
                    updateTiles();
                    updateCamera();
                }
            }
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
